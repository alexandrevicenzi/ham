#! /usr/bin/perl -w

use strict;

use XML::Simple;
use File::Spec;
use File::Path qw(make_path);
use Git::Repository;
use URI;
use IO::Select;
use Cwd;
use JSON;

$ENV{LC_ALL} = 'C';

my $prog = 'ham';

sub filter_projects
{
  my ($projects, $argv) = @_;
  $argv = \@ARGV unless defined $argv;

  if (defined $argv->[0]) {
    my %r = ();
    foreach my $n (@$argv) {
      $r{$n} = $projects->{$n} if exists $projects->{$n};

      # handle '.' magic, find out project is the best hitfor
      # the current working directory
      if ($n eq '.') {
        my $cwd = getcwd;
        my $hit_p = '';
        my $hit;
        foreach my $p (values %$projects) {
          my $path = $p->abs_path;
          if ($cwd =~ /^$path(\/+|$)/ and length $path > length $hit_p) {
            $hit_p = $path;
            $hit = $p;
          }
        }

        $r{$hit->{name}} = $hit if defined $hit;
      }
    }
    return \%r;
  }
  return $projects;
}


package Options {
  use Getopt::Long;
  sub new
  {
    shift;
    my ($usage, @options) = @_;
    my $self = { usage => $usage };
    if (ref $options[0] eq 'HASH') {
      $self->{conf} = shift @options;
    } else {
      $self->{conf} = {};
    }

    $self->{options} = [@options];
    return bless $self, 'Options';
  }

  sub get
  {
    my ($self) = shift;
    $self->{opt} = {};
    my @pre_args;
    if (defined $self->{conf}->{'pre_args'}) {
      @pre_args = ();
      while (@ARGV and substr($ARGV[0], 0, 1) ne '-') {
        push @pre_args, shift @ARGV;
      }
    }

    if (defined $self->{conf}->{'extra_args'}) {
      $self->{opt}->{__EXTRA_ARGS} = [];
      for (my $i = 0; $i < scalar(@ARGV); $i++) {
        if ($ARGV[$i] eq '--') {
          $self->{opt}->{__EXTRA_ARGS} = [ @ARGV[$i+1 .. $#ARGV] ];
          @ARGV = $i > 0 ? @ARGV[0 .. $i-1] : ();
          last;
        }
      }
    }

    my $res = GetOptions($self->{opt}, map { $_->[0] } @{$self->{options}});
    $self->{opt}->{__PREARGS} = \@pre_args;
    return $res;
  }

  sub opt { return $_[0]->{opt}; }

  sub usage
  {
    my ($self, $cmd) = @_;

    sub option_desc(@);
    sub option_spec($$);

    my $usage = $self->{usage};
    my $o = join(' ', map { option_spec($_->[0], $_->[2]) } @{$self->{options}});
    $usage =~ s/%o/$o/g;
    $usage =~ s/%c/$cmd/g;

    my $options = [];
    foreach my $o (@{$self->{options}}) {
      next if ref $o ne 'ARRAY';
      push @$options, option_desc(@$o);
    }

    return ($usage, $options);

    sub pretty_opts($$)
    {
      my ($o, $c) = @_;
      my $op = '';
      $o =~ /^([a-zA-Z0-9\-|]+)(?:([\!\+=:])(.+))?$/;
      my @opts = split(/\|/, $1);
      my ($spec, $type) = ($2, $3);
      my $args;
      my $optional = (defined $spec and $spec eq ':') ? 1 : 0;
      if (defined $spec and $spec =~ /[:=]/) {
        my %types = ( s => '<string>', i => '<int>', o => '<int>', f => '<float>' );
        if (defined $c->{arg}) {
          $args = $c->{arg};
        } elsif (defined $types{$type}) {
          $args = $types{$type};
        } else {
          $args = '<unk>';
        }
      }

      sub pretty_opt($$$)
      {
        my ($opt, $optional, $arg) = @_;
        return "--$opt=$arg" if length($opt) > 1 and defined $arg and not $optional;
        return "-$opt $arg" if length($opt) == 1 and defined $arg and not $optional;
        return "--$opt"."[=$arg]" if length($opt) > 1 and defined $arg and $optional;
        return "-$opt [$arg]" if length($opt) == 1 and defined $arg and $optional;
        return "-$opt" if length($opt) == 1;
        return "--$opt";
      }

      @opts = map { pretty_opt($_, $optional, $args) } @opts;
      return @opts;
    }

    sub option_desc(@)
    {
      my ($o, $d, $c) = @_;
      return [] unless defined $o;
      my @os = pretty_opts($o, $c);
      my $txt = join(", ", @os);
      return [$txt, $d];
    }

    sub option_spec($$)
    {
      my ($o, $c) = @_;
      my @os = pretty_opts($o, $c);
      my $txt = join("|", @os);
      return $txt if defined $c->{required};
      return "[$txt]";
    }
  }
}

package Subcommand {
  sub new
  {
    shift;
    my %o = @_;
    return bless {
      cmd  => $o{cmd},
      opt  => Options->new(ref $o{syn} eq 'ARRAY' ? @{$o{syn}} : $o{syn}),
      desc => $o{desc}
    }, 'Subcommand';
  }

  sub add
  {
    my ($self, $name, $subcmd) = @_;
    $self->{sub}->{$name} = $subcmd;
  }

  sub alias
  {
    my ($self, $name, $orig) = @_;
    $self->{alias}->{$name} = [ split(/\s+/, $orig) ];
  }

  sub sub { return $_[0]->{sub}; }

  sub usage
  {
    my $self = shift;
    return ($self->{opt}->usage(@_), $self->{desc});
  }

  sub find
  {
    my ($self, $command) = @_;
    if (not defined $self->sub or not @ARGV or substr($ARGV[0],0,1) eq '-') {
      return (1, $self, $command);
    }

    while (1) {
      my $subcmd = shift @ARGV;
      my $s = $self->sub->{$subcmd};
      if (not defined $s) {
        my $alias = $self->{alias}->{$subcmd};
        if (defined $alias) {
          unshift @ARGV, @$alias;
          next;
        }
        return (undef, $self, $command, $subcmd);
      }
      return $s->find("$command $subcmd");
    }
  }

  sub run
  {
    my ($self, $command) = @_;
    my $ok = 0;
    my $subcmd;
    ($ok, $self, $command, $subcmd) = $self->find($command);
    if (not $ok) {
      print STDERR "error: unknown command $command $subcmd\n";
      $self->print_usage($command, *STDERR); # exits
    }

    return $self->_exec($command);
  }

  sub _exec
  {
    my ($self, $command) = @_;
    $self->print_usage($command, *STDERR) unless $self->{opt}->get;
    return $self->{cmd}->($self->{opt}->opt, $command, $self);
  }

  sub print_usage
  {
    my $out = defined $_[2] ? $_[2] : *STDERR;
    my $old = select($out);
    shift->_print_usage(@_);
    select($old);
    exit(129);
  }

  sub usage_error
  {
    print STDERR "$_[2]\n";
    shift->print_usage($_[0], *STDERR);
  }

  sub _print_usage(**)
  {
    my ($subcmd, $cmd) = @_;

    sub strip_spaces($)
    {
      my $i = shift;
      $i =~ s,[\n\t ]+, ,sg;
      return $i;
    }

    my ($usage, $options, $description) = $subcmd->usage($cmd);
    $description = strip_spaces($description);

format USAGE =
  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  $usage
~~          ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            $usage
.
format DESCR =
~~      ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        $description
.
    local $~ = 'USAGE';
    local $: = " \n";
    write;
    $~ = 'DESCR';
    print "\n";
    write;
    print "\n";
    foreach my $o (@$options) {
      my $option = $o->[0];
      my $desc = strip_spaces($o->[1]);
format OPTION =
        ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<...
        $option
~~          ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            $desc
.
        $~ = 'OPTION';
      write;
      print "\n";
    }

    if (defined $subcmd->sub) {
      #print "  SUB COMMANDS\n";
      foreach my $c (sort keys %{$subcmd->sub}) {
        my $d =$subcmd->sub->{$c};
        $d->_print_usage("$cmd $c");
        print "\n";
      }
    }

    if (defined $subcmd->{alias}) {
      print "  ALIASES\n";
      foreach my $c (sort keys %{$subcmd->{alias}}) {
        my $a = join(' ', @{$subcmd->{alias}->{$c}});
format ALIAS =
        @<<<<<<<<<<<<<<<<<<... =  ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
        $c,                       $a
~~                                ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                  $a
.
        $~ = 'ALIAS';
        write;
      }
    }
  }

}

###### the main command (no command given) ############################
my $commands = Subcommand->new(
  cmd  => sub { $_[2]->print_usage($_[1], *STDOUT); },
  syn  => '%c',
  desc => 'print help'
);

$commands->add(help => Subcommand->new(
  cmd => sub {
    if (@ARGV) {
      my ($ok, $cmd, $command, $sub) = $commands->find($prog);
      if ($ok) {
        $cmd->print_usage($command, *STDOUT);
      } else {
        print STDERR "error: unknown command $command $sub\n";
        $cmd->print_usage($command, *STDERR);
      }
    }
    $commands->print_usage($prog, *STDOUT);
  },
  syn => '%c',
  desc => 'print help'
));


my $repo_dir;
my $repo_base;
my $repo_subdir = '.ham';

sub get_repo_dir(@)
{
  my $try = shift;
  return $repo_dir if defined $repo_dir;
  my $cwd = getcwd;

  my ($vol, $dirs, $file) = File::Spec->splitpath($cwd, no_file => 1);
  my @dirs = File::Spec->splitdir($dirs);

  while (1) {
    my $d = File::Spec->catpath($vol, File::Spec->catdir(@dirs, $repo_subdir), '');
    if (-d $d) {
      $repo_dir = $d;
      $repo_base = File::Spec->catpath($vol, File::Spec->catdir(@dirs), '');
      return $repo_dir;
    }

    return undef if not @dirs and $try;
    die "not in $prog repo directory (could not find $repo_subdir)\n" unless @dirs;
    pop @dirs;
  }
}

sub repo_base(@)
{
  get_repo_dir(@_);
  return $repo_base;
}

sub repo_manifest() { get_repo_dir().'/manifest.xml' }
sub repo_config() { get_repo_dir().'/config' }

my $info = [];
my $err  = [];

## stream to be processed by a stream processor
package Stream {
  use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
  sub new($$$@)
  {
    shift;
    my $fh = shift;
    my $cb = shift;
    my @args = @_;
    my $self = {};
    $self->{buffer} = '';
    $self->{fh} = $fh;
    $self->{cb} = $cb;
    $self->{sep} = "\n\r";
    $self->{args} = \@args;
    my $flags = fcntl($fh, F_GETFL, 0);
    fcntl($fh, F_SETFL, $flags | O_NONBLOCK);
    return bless $self, 'Stream';
  }

  sub process($)
  {
    my $self = shift;
    my $func = shift;
    my @args = @_;
    my $buffer = \$self->{buffer};
    my $fh = $self->{fh};
    my $sep = $self->{sep};

    my $buf = '';
    my $n = sysread($fh, $buf, 1024);
    $$buffer .= $buf;
    if ($$buffer =~ s/([^\r\n]+)[\r\n]//) {
      $self->{cb}->(0, $1, @{$self->{args}});
      return 1;
    } elsif ($n == 0) {
      $self->{cb}->(1, $$buffer, @{$self->{args}});
      $$buffer = '';
      $self->{done} = 1;
      return 0;
    }
  }
};


## A stream processor processes a set of stream and
## runs callbacks when there is new input
package Stream::Process {

  ## create a new stream processor
  sub new
  {
    my $s = { streams => [] };
    return bless $s, 'Stream::Process';
  }

  ## add new stream to the processor
  sub add($@)
  {
    my $self = shift;
    foreach my $s (@_) {
      push @{$self->{streams}}, $s unless $s->{done};
    }
  }

  ## delete a stream from the processor
  sub del($$)
  {
    my ($self, $s) = @_;
    @{$self->{streams}} = grep { $_ != $s } @{$self->{streams}};
  }

  ## delete all closed stream from the processor
  sub gc($)
  {
    my ($self) = @_;
    @{$self->{streams}} = grep { not $_->{done} } @{$self->{streams}};
  }

  ## are there any sreams left ?
  sub done($)
  {
    my ($self) = @_;
    return not scalar(@{$self->{streams}});
  }

  ## do stream processing
  sub process($)
  {
    my ($self) = @_;

    return undef if $self->done;

    my @handles = map { $_->{fh} } @{$self->{streams}};

    while (my @ready = IO::Select->new(@handles)->can_read) {
      foreach my $h (@ready) {
        my ($s) = grep { $_->{fh} == $h } @{$self->{streams}};
        if (not $s->process) {
          # stream closed ...
          $self->gc;
          return $s;
        }
      }
    }
  }
}

## queue to handle parallel work
package Process_queue {

  ## a running job
  package Process {
    sub new
    {
      shift;
      my $cmd = shift;
      my %opts = @_;
      my $self = {};

      $self->{command} = $cmd;
      $self->{done} = 0;

      my @args = ();
      if (defined $opts{args}) {
        @args = ($opts{args});
        @args = @{$opts{args}} if ref $opts{args} eq 'ARRAY';
      }

      my $finish_cb = $opts{finish};

      my $finish = sub {
        my $what = shift;
        delete $self->{$what};
        if (++$self->{done} == 2) {
          $finish_cb->($self, @args) if defined $finish_cb;
          $cmd->close;
          delete $self->{command};
        }
      };

      my $out_cb = $opts{out};
      my $err_cb = $opts{err};
      %opts = ();

      $self->{stdout} = Stream->new($cmd->stdout, sub {
          my ($finished, $data) = @_;
          $out_cb->($self, $data, @args) if $out_cb;
          $finish->('stdout') if $finished;
        });
      $self->{stderr} = Stream->new($cmd->stderr, sub {
          my ($finished, $data) = @_;
          $err_cb->($self, $data, @args) if $err_cb;
          $finish->('stderr') if $finished;
        });

      return bless $self, 'Process';
    }

    sub stdout { $_[0]->{stdout} }
    sub stderr { $_[0]->{stderr} }
    sub done   { $_[0]->{done} == 2 }
  }


  ## create a new work queue
  sub new
  {
    shift;
    my %o = @_;
    $o{max} = 8 unless defined $o{max};
    return bless {
      finish   => $o{finish},
      max      => $o{max},
      queue    => [],
      running  => [],
      sp       => Stream::Process->new,
    }, 'Process_queue';
  }


  ## test if the queue is fully loaded (max numbber of runnning processes)
  sub full($)
  {
    my $self = shift;
    return scalar(@{$self->{running}}) >= $self->{max};
  }

  ## queue new work
  sub queue($$@)
  {
    my ($self, $command, %opts) = @_;
    push @{$self->{queue}}, $command;
  }

  ## run all the queued work
  sub work($)
  {
    my $self = shift;
    while (scalar(@{$self->{queue}})) {
      $self->_run_next unless $self->full;
      $self->{sp}->process;
    }

    while ($self->{sp}->process) {}
  }

  ## private: update the progress indicator
  sub _update_progress
  {
    my $self = shift;
    my $txt = '';
    foreach my $r (@{$self->{running}}) {
      $txt .= '['.$r->{err_msg}.']' if defined $r->{err_msg};
    }

    print STDERR "\r$txt\e[K" if $txt ne '';
  }

  ## private functions follow ...
  ## private: run the next job
  sub _run_next($)
  {
    my $self = shift;
    my $next = shift @{$self->{queue}};
    return 0 unless defined $next;

    my ($cmd, %o) = $next->();

    sub parse_stream($@)
    {
      my ($what, $proc, $data, $self, $opts) = @_;
      my $r = (grep { $_->{proc} == $proc } @{$self->{running}})[0];
      my @args = ($opts->{args});
      @args = @{$opts->{args}} if defined $opts->{args} and ref $opts->{args} eq 'ARRAY';
      my $info = $opts->{$what}->($data, @args) if defined $opts->{$what};
      $r->{$what.'_msg'} = $info if defined $info;
      $self->_update_progress if defined $info;
    }

    my %popts = (
      args   => [ $self, { %o } ],
      finish => sub {
        my ($proc, $self, $opts) = @_;
        $self->{running} = [ grep { $_->{proc} != $proc } @{$self->{running}} ];
        my @args = ($opts->{args});
        @args = @{$opts->{args}} if defined $opts->{args} and ref $opts->{args} eq 'ARRAY';
        my $info = $opts->{finish}->($proc, @args) if defined $opts->{finish};
        if (defined $info) {
          print STDERR "\r$info\e[K\n";
          $self->_update_progress;
        }
      },

      err => sub { parse_stream('err', @_); },
      out => sub { parse_stream('out', @_); },
    );
    my $e = Process->new($cmd, %popts);
    push @{$self->{running}}, { proc => $e };
    $self->{sp}->add($e->stdout, $e->stderr);
    return 1;
  }
}

#################################
# Git::Repository::Plugin::KK
package Git::Repository::Plugin::KK {
  use Git::Repository::Plugin;
  our @ISA      = qw( Git::Repository::Plugin );
  sub _keywords { qw( rev_parse cat_object ) }

  sub rev_parse
  {
    # skip the invocant when invoked as a class method
    return undef if !ref $_[0];
    my $r = shift;
    my $res = $r->run('rev-parse', '--revs-only', @_, { quiet => 1, fatal => [-128 ]});
    return undef unless defined $res;
    return undef unless $res ne '';
    return $res;
  }

  sub cat_object
  {
    # skip the invocant when invoked as a class method
    return undef if !ref $_[0];
    my $r = shift;
    return $r->run('cat-file', '-p', $_[0]);
  }
}

Git::Repository::Plugin::KK->install();

##########################################################################
# Project package
package Project {
  use File::Spec::Functions qw(catdir splitdir);

  ## get the absolute base path to the work tree of this project
  sub abs_path($)
  {
    my $self = shift;
    my $base = ::repo_base();
    return catdir($base, $self->{path});
  }

  sub repo_dir_rel($$)
  {
    my ($self, $sub) = @_;
    $sub = $self->{path} unless defined $sub;
    $sub = substr $sub, 1 if substr($sub, 0, 1) eq '/';
    my @d = splitdir($sub);
    my $pfx = $repo_subdir;
    $pfx = catdir('..', $pfx) foreach @d;
    return $pfx;
  }

  ## test if the work tree diretory exists
  sub exists($) { return -e $_[0]->abs_path; }

  ## check forthe existence of the '.git' directory
  sub is_git_repo($) { return -e $_[0]->abs_path.'/.git'; }

  ## get the Git::Repository object for this project (incl. a work tree)
  sub git
  {
    my $self = shift;
    my $err = shift;

    return $self->{_repo} if defined $self->{_repo};

    if (not $self->is_git_repo) {
      push @$err, "$self->{path} is not a git repository (.git missing)" if defined $err;
      return undef;
    }

    my $r = $self->{_bare_repo} = $self->{_repo}
          = Git::Repository->new(git_dir => $self->abs_path.'/.git',
                                 work_tree => $self->abs_path);
    if (not defined $r and defined $err) {
      push @$err, "$self->{path} is not a valid git repository";
      return undef;
    }

    return $r;
  }

  ## get the Git::Repository object for this project (bare)
  sub bare_git
  {
    my $self = shift;
    my $err = shift;
    return $self->{_bare_repo} if defined $self->{_bare_repo};

    if (not $self->is_git_repo) {
      push @$err, "$self->{path} is not a git repository (.git missing)" if defined $err;
      return undef;
    }

    my $r = $self->{_bare_repo} = Git::Repository->new(git_dir => $self->abs_path.'/.git');
     if (not defined $r and defined $err) {
      push @$err, "$self->{path} is not a valid git repository";
      return undef;
    }

    return $r;
  }


  ## initialize the project work tree (.git)
  sub init($)
  {
    my $self = shift;
    Git::Repository->run( init => $self->abs_path );
    $self->{_bare_repo} = $self->{_repo} = Git::Repository->new(work_tree => $self->abs_path);
  }

  ## do a conditional checkout for sync
  sub sync_checkout
  {
    my ($self, $opts) = @_;
    my $git = $self->git($err);
    return 0 unless defined $git;

    my $head = $git->rev_parse('--abbrev-ref', 'HEAD');

    # return if we have already a valid checkout, don't touch the working copy
    if (defined $head) {
      return 1 unless $opts->{rebase};

      if ($head ne $self->{revision}) {
        push @$info, "$self->{path}: not on branch $self->{revision}, skip rebase";
        return 1;
      }

      my $remote = $self->{_remote}->{name};
      my $remote_ref_n = "refs/remotes/$remote/$head";
      my $remote_ref = $git->rev_parse($remote_ref_n);
      if (not $remote_ref) {
        push @$info, "$self->{name}: no corresponding remote branch found ($head), skipping rebase";
        return 1;
      }

      push @$info, map { "$self->{path}: $_" } $git->run('rebase', $remote_ref_n);
      return 1;
    }

    my $revision = $self->{revision};
    print STDERR "checkout $self->{name} @ $self->{path} ($revision)\n";
    if (not defined $revision) {
      push @$err, "$self->{name} @ $self->{path} has no revision to checkout";
      return 0;
    }

    if (not defined $self->{_remote} or not defined $self->{_remote}->{name}) {
      push @$err, "$self->{name} @ $self->{path} has no valid remote";
      return 0;
    }

    my $remote_name = $self->{_remote}->{name};
    if (not $git->rev_parse("$remote_name/$revision")) {
      push @$err, "$self->{name} @ $self->{path} has no branch named $revision";
      return 0;
    }

    $self->checkout('-b', $revision, '--track', $remote_name.'/'.$revision);
    return 1;
  }

  ## prepare the git repo after sync, incl. checkout
  sub prepare($$)
  {
    my ($self, $opts) = @_;
    return 0 unless $self->sync_checkout($opts);
    my $git = $self->bare_git;
    if (defined $self->{_remote}->{review} and $self->{_remote}->{review} ne '') {
      my $hooks = $git->git_dir.'/hooks';
      if (not -e "$hooks/commit-msg") {
        make_path($hooks) unless -d $hooks;
        my $base = ::repo_base();
        if (index($hooks, $base) != 0) {
          push @$err, "$hooks is not within our repo at $base";
          return 0;
        }

        my $rel_hooks = $self->repo_dir_rel(substr $hooks, length($base));
        symlink(catdir($rel_hooks, "hooks/commit-msg"), "$hooks/commit-msg")
          or push @$err, "fatal: link $hooks/commit-msg: $!";
      }

      $git->run(config => '--bool', 'gerrit.createChangeId', 'true');
    } else {
      $git->run(config => '--bool', 'gerrit.createChangeId', 'false');
    }
    return 1;
  }


  sub _fetch_progress($$)
  {
    local $_ = shift;
    my $self = shift;
    if (/^remote: Finding sources:\s*([0-9]+%).*$/) {
      return "$self->{name}: $1";
    } elsif (/^Receiving object:\s*([0-9]+%).*$/) {
      return "$self->{name}: $1";
    } elsif (/^Resolving deltas:\s*([0-9]+%).*$/) {
      return "$self->{name}: $1";
    }
    return undef;
  }

  sub _collect($$)
  {
    local $_ = shift;
    my $self = shift;
    push @{$self->{output}}, $_;
  }

  sub fetch($@)
  {
    my $self = shift;
    return (
      $self->bare_git->command('fetch', '--progress', @_, { quiet => 1 }),
      out => \&_collect, err => \&_fetch_progress, args => $self,
      finish => sub {"done fetching $self->{name}" }
    );
  }

  ## checkout the work tree
  sub checkout($@)
  {
    my $r = shift;
    my @args = @_;
    my $branch = \(grep { not /^-/ } @args)[0];
    $$branch =~ s,\{UPSTREAM\},$r->{revision},g;

    my $git = $r->git;
    if (not $git) {
      push @$err, "$r->{name} in $r->{path} is no git repo (may be you need 'sync')";
      return 128;
    }

    my $head = $git->rev_parse('--abbrev-ref', 'HEAD');
    return if defined $head and $head eq $$branch;
    $head = '' unless defined $head;

    my $cmd = $git->command('checkout', @args, '--', {fatal => [-128], quiet => 1});
    my @cerr = $cmd->stderr->getlines;

    if (grep /invalid reference: $$branch/, @cerr) {
      push @$info, "$r->{name} has no refernece $$branch, stay at the previous head ($head)";
      return 128;
    }
    if (grep /(Already on )|(Switched to branch )'$$branch'/, @cerr) {
      return 128;
    }

    if (grep /Switched to a new branch /, @cerr) {
      # this happens for the initial checkout of a remote branch
      return 128;
    }

    if (@cerr) {
      push @$err, "$r->{name} in $r->{path}";
      chomp(@cerr);
      push @$err, @cerr;
    }
    return $cmd->exit;
  }

  ## sync #############################################
  sub sync($)
  {
    my $self = shift;
    my $remote_name = $self->{_remote}->{name};
    my $r;
    ::make_path($self->abs_path) unless $self->exists;
    if ($self->is_git_repo) {
      $r = $self->bare_git;
      #print STDERR "fetch $self->{name} from $remote_name\n";
      return $self->fetch($remote_name);
    } else {
      #print "run: ($self->{path}) git clone $remote_name\n";
      my $url = $self->{_remote}->{fetch};
      $url .= '/' unless substr($url, -1, 1) eq '/';
      $url .= $self->{name};
      $r = $self->init;
      $r->run('remote', 'add', $remote_name, $url);
      return $self->fetch($remote_name);
    }
  }

  ###### status #########################################
  sub status($)
  {
    my $self = shift;
    my $r = $self->git($err);
    return unless $r;
    my @s = $r->run(status => '--porcelain', '-b');
    if ($s[0] =~ /##.*(ahead|behind)/ or scalar(@s) > 1) {
      print "project: $self->{name} at ".$self->abs_path."\n";
      print join("\n", @s)."\n";
    }
    return;
  }

  sub check_rev_list($$$$)
  {
    my ($prj, $r, $src_br, $rev_list) = @_;

    my @no_chid = ();
    my %duplicate_chid = ();
    my @duplicate_chid = ();
    my @multiple_chid = ();

    foreach my $c (@$rev_list) {
      my @cmt = $r->cat_object($c);
      my @chid = grep /^Change-Id:/, @cmt;
      if (not @chid) {
        push @no_chid, $c;
        next;
      } elsif (scalar(@chid) > 1) {
        push @multiple_chid, $c;
        next;
      }

      my $chid = $chid[0];
      $chid =~ s/^Change-Id:\s*(\S+)/$1/;

      if ($chid eq '') {
        push @no_chid, $c;
        next;
      }

      if ($duplicate_chid{$chid}) {
        push @{$duplicate_chid{$chid}}, $c;
        push @duplicate_chid, $chid;
        next;
      } else {
        $duplicate_chid{$chid} = [ $c ];
      }
    }

    my $list_errors = sub
    {
      my ($msg, $e) = @_;
      return unless @$e;
      push @$err, "$prj->{path}: branch $src_br: $msg";
      foreach my $c (@$e) {
        my $x = $r->run('log', '-n', '1' ,'--oneline', '--color=always', $c);
        push @$err, "  $x";
      }
    };

    $list_errors->("the following commits have no change ID", \@no_chid);
    $list_errors->("the following commits have multiple chage IDs", \@multiple_chid);
    foreach my $id (@duplicate_chid) {
      $list_errors->("the following commits have the same change ID (you should squash them)",
                     $duplicate_chid{$id});
    }

    return 0 if @no_chid or @multiple_chid or @duplicate_chid;
    return 1;
  }

  sub check_for_upload()
  {
    my ($prj, $warn, $src_br, $dst_br, $approve_cb) = @_;
    my $r = $prj->git($err);
    my $src_rev = $r->rev_parse($src_br);

    if (not $src_rev) {
      push @$warn, "$prj->{path}: branch has no branch $src_br, skipping.";
      return 0;
    }

    my $remote = $prj->{remote};
    $dst_br = $prj->{revision} unless defined $dst_br;
    my $rem_br = "$remote/$dst_br";
    my $dst_rev = $r->rev_parse($rem_br);

    if (not $dst_rev) {
      push @$warn, "$prj->{path}: branch has no branch $remote/$dst_br, skipping.";
      return 0;
    }

    # skip if there is nothing to do
    return 0 if $src_rev eq $dst_rev;

    my @commits = $r->run('rev-list', '--ancestry-path', "^$dst_rev", $src_rev);
    if (not @commits) {
      push @$err, "$prj->{path}: $src_br is not derived from $rem_br";
      return 0;
    }

    # check if all commits have change IDs
    return 0 unless $prj->check_rev_list($r, $src_br, \@commits);

    # check the number of changes for this branch
    my $num_changes = scalar(@commits);
    if ($num_changes > 1) {
      if (not defined $approve_cb or not $approve_cb->($prj, \@commits)) {
        push @$err, "$prj->{path}: branch $src_br has more than one ($num_changes) change for $rem_br";
        return 0;
      }
    }
    return wantarray ? (1, $src_br, $dst_br) : 1;
  }

}
##########################################################################

my @project_attrs = ('revision', 'remote');

sub apply_default($$$)
{
  my ($manifest, $r, $what) = @_;
  $r->{$what} = $manifest->{default}->{$what} unless defined $r->{$what};
}

sub load_projects
{
  my $file = shift;
  $file = repo_manifest();
  open my $mf, "<".get_repo_dir().'/manifests_url';
  my $manifest_url = <$mf>;
  close $mf;
  chomp($manifest_url);
  $manifest_url = URI->new($manifest_url);
  my $manifest = XMLin($file,
    ForceArray => ['project', 'remote'],
    KeyAttr => { project => "+name", remote => "+name" });

  my $projects = $manifest->{project};
  foreach my $r (values %$projects) {
    foreach my $attr (@project_attrs) {
      apply_default($manifest, $r, $attr);
    }

    $r->{_remote} = $manifest->{remote}->{$r->{remote}};
    bless $r,'Project';
  }

  foreach my $r (values %{$manifest->{remote}}) {
    $r->{fetch} = URI->new_abs($r->{fetch}, $manifest_url)->as_string;
    $r->{review} = URI->new_abs($r->{review}, $manifest_url)->as_string;
  }
  return $projects;
}

##########################################################################

sub foreach_repo_r($$@)
{
  my ($func, $projects, $progress, @args) = @_;
  my $cnt = 1;
  my $total = scalar(@$projects);
  foreach my $r (@$projects) {
    print STDERR "\r\e[K($cnt/$total) " if $progress;
    my $res = $func->($r, @args);
    return $res if $res;
    $cnt++;
  }
  print STDERR "\n" if $progress and $total;
  0;
}

sub print_errors
{
  my %opts = @_;
  foreach my $i (@$info) {
    print "$i\n";
  }

  $info = [];

  my $errpfx = defined $opts{no_prefix} ? '' : 'error: ';
  foreach my $e (@$err) {
    print STDERR "$errpfx$e\n";
  }

  if ($opts{err_msg} and @$err) {
    print STDERR "$opts{err_msg}\n";
  }

  if ($opts{exit} and @$err) {
    exit($opts{exit});
  }

  if ($opts{err_val} and @$err) {
    $err = [];
    return $opts{err_val};
  }
  $err = [];

  return 0;
}

sub sorted_and_filtered_projects
{
  my $prjs = shift;
  $prjs = \@ARGV unless defined $prjs;
  my $projects = filter_projects(load_projects(), $prjs);
  return [ sort { $a->{name} cmp $b->{name} } values %$projects ];
}

sub foreach_repo($@)
{
  my ($func, $prjs, $progress, @args) = @_;
  $prjs = \@ARGV unless defined $prjs;

  my $res = foreach_repo_r($func, sorted_and_filtered_projects($prjs), $progress, @args);
  print_errors();
  return $res;
}

####### list projects #################################
$commands->add(list => Subcommand->new(
  cmd  => \&cmd_list_projects, 
  syn  => '%c',
  desc => "list all projects managed by $prog"
));

sub cmd_list_projects($$)
{
  foreach_repo(sub { print "$_[0]->{name} $_[0]->{path}\n"; return 0; }, \@ARGV);
}


###### initialize managed directory ####################

sub place_commit_msg_hook()
{
  my $d = get_repo_dir();
  make_path("$d/hooks") unless -d "$d/hooks";
  open my $cm, ">$d/hooks/commit-msg"
    or die "fatal: could not open $d/hooks/commit-msg for writing: $!\n";

  print $cm gerrit_commit_msg_hook();
  close $cm;
  chmod 0755, "$d/hooks/commit-msg";
}

###### init #############################################
$commands->add(init => Subcommand->new(
  cmd => \&cmd_init,
  syn => [
    '%c %o',
    [ 'url|u=s',    'URL of the manifest repository',    { arg => '<manifest url>' } ],
    [ 'file|f|m=s', 'set the name of the manifest file', { arg => '<manifest>' } ],
  ],
  desc => "initialize $prog meta project in the curent directory"
));

sub cmd_init($)
{
  die "fatal: $prog repo already initialized $repo_dir\n" if defined get_repo_dir(1);
  $repo_dir = $repo_subdir;
  my $opt = shift;
  my $repo_dat_src = $opt->{file};
  if (defined $opt->{url}) {
    # try to download a manifest repo
    $repo_dat_src = 'default.xml' unless defined $repo_dat_src;
    mkdir($repo_subdir);
    Git::Repository->run(clone => $opt->{url}, "$repo_subdir/manifests");
    symlink("manifests/$repo_dat_src", "$repo_subdir/manifest.xml");
    open my $u, ">$repo_subdir/manifests_url";
    print $u "$opt->{url}\n";
    close $u;
  } else {
    # use a local file as manifest and copy it
    my $repo_dat = repo_manifest();
    die "error: you need to specify a manifest XML file\n" if not defined $repo_dat_src;
    die "error: $repo_dat_src is no readable file\n" if not (-f $repo_dat_src and -r $repo_dat_src);
    mkdir($repo_subdir);
    open my $rd, ">$repo_dat" or die "error: cannot open $repo_dat: $!\n";
    open my $rs, "<$repo_dat_src" or die "error: cannot open $repo_dat_src: $!\n";
    while (<$rs>) { print $rd $_; }
    close $rs;
    close $rd;
  }

  place_commit_msg_hook();
  return 0;
}


###### sync ###########################################
$commands->add(sync => Subcommand->new(
  cmd  => \&cmd_sync,
  syn  => [
    '%c [<project>...]',
    [ 'rebase',  q|rebase the current branch onto the
                   corresponging branch in the projects remote| ]
  ],
  desc => 'checkout/update all projects'
));

sub cmd_sync
{
  my ($opts, $command, $cmd) = @_;
  # update manifest repo, if there is any
  if (-d get_repo_dir().'/manifests/.git') {
    my $r = Git::Repository->new(work_tree => get_repo_dir().'/manifests');
    $r->run(pull => 'origin');
  }
  place_commit_msg_hook();

  my $projects = sorted_and_filtered_projects(\@ARGV);
  my $q = Process_queue->new();

  foreach my $r (@$projects) { $q->queue(sub { $r->sync; }); }
  $q->work;

  print_errors(exit => 128);
  print STDERR "Preparing gits .....................\n";

  $_->prepare($opts) foreach @$projects;
  print_errors(exit => 128);

  return 0;
}


###### status #########################################
$commands->add(status => Subcommand->new(
  cmd  => sub { foreach_repo(sub { shift->status; 0;}) },
  syn  => '%c [<project>...]',
  desc => 'show the status of all projects'
));


###### forall #######################################
$commands->add(forall => Subcommand->new(
  cmd => \&cmd_forall,
  syn => [
    '%c [<project>...] %o -- <cmd> [<arg>...]',
    { pre_args => 1 },
    [ 'abort-on-errors|e' , 'Abort if a command exits with an exitcode other than zero' ],
    [ 'p',                  'print project name before each execution of <cmd>' ],
    [ 'vars|i',           qq|prelace special '{...}' tokens within the arguments| ],
  ],
  desc => 'run <cmd> for all projects'
));

sub cmd_forall($$$)
{
  my ($opt, $cmd, $subs) = @_;
  my $print_prj = $opt->{p};

  if (not @ARGV) {
    $subs->print_usage($cmd);
  }

  my $cwd = getcwd;

  my $res = foreach_repo(sub {
      my $r = shift;
      print "$r->{name}: $r->{path}\n" if $print_prj;
      chdir $r->abs_path;
      my @argv = @ARGV;
      if ($opt->{vars}) {
        my $upstream = "refs/remotes/$r->{_remote}->{name}/$r->{revision}";
        s,\{UPSTREAM\},$upstream,g foreach @argv;
      }
      my $res = system(@argv);
      return ($res) if $res and $opt->{'abort-on-errors'};
      return 0;
    }, $opt->{__PREARGS});

  chdir $cwd;
  return $res;
}


####### checkout ################################
$commands->add(checkout => Subcommand->new(
  cmd  => \&cmd_checkout,
  syn  => [
    '%c <branch> [<project>...]',
    [ 'abort-on-errors|e', 'Abort on any error, otherwise all projects will be interated' ]
  ],
  desc => 'checkout <branch> in all projects'
));

$commands->alias(co => 'checkout');

sub cmd_checkout
{
  my ($opts, $command, $cmd) = @_;
  my $branch = shift @ARGV;
  $cmd->print_usage($command) unless defined $branch;
  my $abt = $opts->{'abort-on-errors'};
  return foreach_repo(sub {
      my $r = shift->checkout($branch);
      return $r if $r and $abt;
      return 0;
    });
}


###### start a new topic branch ##################
$commands->add(start => Subcommand->new(
  cmd => \&cmd_start,
  syn => [
    '%c %o <branch name> [<projects>...]',
    [ 'base|t=s', 'starting point for the new branch', { arg => '<start-point>' } ],
  ],
  desc => 'start a new topic branch <branch> in all projects'
));

sub cmd_start
{
  my $opt = shift;
  my $branch = shift @ARGV;

  $_[2]->print_usage($_[1]) unless defined $branch;
  my $base = $opt->{base};
  my @args = ('--track', '-b', $branch);
  push @args, $base if defined $base and $base ne '';

  return foreach_repo(sub { shift->checkout(@args) });
}


###### info ####################################
$commands->add(info => Subcommand->new(
  cmd  => \&cmd_info,
  syn  => '%c [<project>...]',
  desc => 'show infos for each project'
));

sub cmd_info($$)
{

  foreach_repo(sub {
  }, \@ARGV);

  0;
}


###### remote #######################################
$commands->add(
  remote => Subcommand->new(
    cmd => sub { $_[2]->print_usage($_[1]); 0; },
    syn => '%c',
    desc => 'manage remotes for all projects'
  )
);

###### remote add ####################################
$commands->sub->{remote}->add(
  add => Subcommand->new(
    cmd  => \&cmd_remote_add,
    syn  => '%c <remote-name> <url> [<project>...]',
    desc => 'add a repository remote for to each git repo using <url> as prefix'
  )
);

sub cmd_remote_add($$)
{
  my $name = shift @ARGV;
  $_[2]->print_usage($_[1]) unless defined $name;
  my $url = shift @ARGV;
  $_[2]->print_usage($_[1]) unless defined $url;
  $url .= '/' unless substr($url, -1, 1) eq '/';
  $url = URI->new($url);
  foreach_repo(sub {
    my $r = shift;
    my $rurl = URI->new_abs($r->{name}, $url);
    #print $url, " => ", $rurl, "\n";
    $r->git->run(remote => 'add', $name, $rurl->as_string);
  });
  return 0;
}


sub approve_dependent_changes
{
  my ($prj, $commits) = @_;
  print STDERR "project $prj->{name} ($prj->{path}) has more than one change,\n".
               "this will produce the following depnendent changes:\n\n";
  my @log = $prj->bare_git->run('log', '--color=always', '--oneline', "$$commits[$#$commits]~1..$$commits[0]");

  print STDERR "$_\n" foreach (@log);
  print STDERR "\ndo you want to upload these changes at once? [y/N]: ";
  my $answer = <STDIN>;
  return 1 if $answer eq 'y' or $answer eq 'Y' or $answer eq 'yes';
  return 0;
}

###### upload ####################################################
$commands->add(upload => Subcommand->new(
  cmd => \&cmd_upload,
  syn => [
    '%c %o [<project>...]',
    [ 't',               'Use branch name as topic' ],
    [ 'topic=s',         'Set <topic> as topic', { arg => '<topic>' } ],
    [ 're|reviewers=s@', q|Add a reviewers. This option takes a comma separated
                           list of reveiwers and may be supplied more than once|, { arg => '<reviewer>' } ],
    [ 'cc=s@',           q|Add email addresses for CC. This option takes a comma
                           separated list of email addresses and may be supplied
                           multiple times|,                                       { arg => '<cc-email>' } ],
    [ 'br=s',            'Upload <local branch> for review',                      { arg => '<local-branch>' } ],
    [ 'dest|destination|D=s', 'Upload commit for destination branch',             { arg => '<branch>' } ],
    [ 'dry-run|n',       'Do a dry run, just print the git commands that would be issued' ],
  ],
  desc => 'upload changes for review'
));

sub cmd_upload($$$)
{
  my $opts = shift;
  $opts->{br} = 'HEAD' unless defined $opts->{br};

  my $projects = sorted_and_filtered_projects(\@ARGV);

  my @warn;
  my @good_projects;

  foreach my $prj (@$projects) {
    my ($upload, $src_br, $dst_br)
      = $prj->check_for_upload(\@warn, $opts->{br}, $opts->{dest},
                               \&approve_dependent_changes);

    push @good_projects, [ $prj, $src_br, $dst_br ] if $upload;
  }

  if (@$err) {
    print_errors();
    print STDERR "Aborting\n";
    return 1;
  }

  if (@warn) {
    foreach my $w (@warn) {
      print "warning: $w\n";
    }
  }

  if (not @good_projects) {
    print "nothing to do for this upload\n";
    return;
  }

  # everything is checked, so start upload
  print "upload changes to ".scalar(@good_projects)." project(s):";
  foreach my $prj (@good_projects) {
    print " $prj->[0]->{name}";
  }
  print "\n";

  my @base_attr;
  foreach my $c (map { split /,/ } @{$opts->{re}}) {
    push @base_attr, "r=$c";
  }

  foreach my $c (map { split /,/ } @{$opts->{cc}}) {
    push @base_attr, "cc=$c";
  }

  foreach my $p (@good_projects) {
    my ($prj, $src_br, $dst_br) = @$p;
    my $dst_ref = "refs/for/".$dst_br;
    my @attrs;
    my $r = $prj->bare_git;
    if ($opts->{topic}) {
      push @attrs, "topic=$opts->{topic}";
    } elsif ($opts->{t}) {
      $src_br = $r->rev_parse('--abbrev-ref', $src_br) if $src_br eq 'HEAD';
      push @attrs, "topic=$src_br";
    }
    push @attrs, @base_attr;
    if (@attrs) {
      $dst_ref .= "%".join(',', @attrs);
    }

    if ($opts->{'dry-run'}) {
      print "$prj->{path}: git push $prj->{remote} $src_br:$dst_ref\n";
    } else {
      push @$info, $r->run('push', $prj->{remote}, "$src_br:$dst_ref");
    }
  }

  return 0;
}


##############################################################
sub fetch_and_co_changes
{
  my ($opts, $prjs, $changes) =  @_;

  my $q = Process_queue->new();
  foreach my $prj (values %$prjs) {
    my $remote_name = $prj->{_remote}->{name};
    my $c = $changes->{$prj->{name}};
    my $change = $c->{change};
    my $patchset = $c->{patchset};

    $q->queue(sub { $prj->fetch($remote_name, "refs/changes/".($change % 100)."/".$change."/".$patchset); });
  }

  $q->work;

  print_errors(exit => 128);

  my $action;
  my @log;

  if (defined $opts->{pull}) {
    $action = sub {
      my $git = $_[0]->git;
      my $head = $git->rev_parse('--abbrev-ref', 'HEAD');
      push @$info, $git->run('merge', 'FETCH_HEAD');
      push @log, [ $_[0], "merged %c/%p into $head" ];
    };
  } elsif (defined $opts->{'cherry-pick'}) {
    $action = sub {
      my $git = $_[0]->git;
      my $head = $git->rev_parse('--abbrev-ref', 'HEAD');
      push @$info, $git->run('cherry-pick', 'FETCH_HEAD');
      push @log, [ $_[0], "cherry picked %c/%p onto $head" ];
    };
  } else {
    $action = sub {
      my $git = $_[0]->git;
      $_[0]->checkout('--detach', '-q', 'FETCH_HEAD');
      push @log, [ $_[0], "checked out %c/%p as detached HEAD" ];
    };
  }

  foreach my $prj (values %$prjs) {
    $action->($prj);
  }

  my $res = print_errors(err_val => 128);

  print "changes:\n";
  foreach my $log (sort { $a->[0]->{name} cmp $b->[0]->{name} } @log) {
    my $prj = $log->[0];
    my $msg = $log->[1];
    my $remote_name = $prj->{_remote}->{name};
    my $c = $changes->{$prj->{name}};
    my $change = $c->{change};
    my $patchset = $c->{patchset};

    $msg =~ s,%c,$change,g;
    $msg =~ s,%p,$patchset,g;

    print "  $prj->{name} [$remote_name]: $msg\n";
  }

  return $res;
}


###### download ####################################
$commands->add(download => Subcommand->new(
  syn => [
    '%c %o <project> <change-nr>[/<patchset>]',
    [ 'cherry-pick|cp|c',  q|Cherry pick the change onto the current branch
                             instead of checking out the change| ],
    [ 'pull|p',            q|Pull (merge) the change into the current branch|],
    [ 'remote|r=s',        q|Use <remote> as git remote to fetch the change,
                             instead of using the remote configured in the manifest.|,
                           { arg => '<remote>' } ]
  ],
  desc => q|Download a change for the given project into your local working copy|,
  cmd => sub {
    my ($opts, $command, $cmd) = @_;
    my ($prjn, $change) = @ARGV;
    $cmd->usage_error($command, 'error: missing prject name') unless defined $prjn;
    my $prj = filter_projects(load_projects(), [ $prjn ])->{$prjn};
    $cmd->usage_error($command, "error: unknown project $prjn") unless defined $prj;
    $cmd->usage_error($command, "error: missing change number") unless defined $change;
    my $patchset = 1;
    if ($change =~ /^([0-9]+)(?:\/([0-9]+))?$/) {
      $change = $1;
      $patchset = $2 if defined $2;
    } else {
      $cmd->usage_error($command, "error: invalid change/patchset format '$change'");
    }

    return fetch_and_co_changes($opts,
      { $prjn => $prj },
      { $prjn => { change => $change, patchset => $patchset }}
    );
  }
));

$commands->alias('cherry-pick' => 'download -c');
$commands->alias('merge' => 'download -p');


###### download-id ####################################
$commands->add('download-id' => Subcommand->new(
  syn => [
    '%c %o <change-id> [<project>...]',
    [ 'cherry-pick|cp|c',  q|Cherry pick the change onto the current branch
                             instead of checking out the change| ],
    [ 'pull|p',            q|Pull (merge) the change into the current branch|],
    [ 'branch|b=s',        q|Get the change for the specified branch, usually
                             any matching change will be downloaded as long as
                             there is no ambiguity.|, { arg => '<branch>' } ],
  ],
  desc => q|Download all changes for all projects with the given change ID (Change-Id)
            to your local working copy|,
  cmd => sub {
    my ($opts, $command, $cmd) = @_;
    my $change_id = shift @ARGV;
    $cmd->usage_error($command, "error: missinng change id") unless defined $change_id;
    my $prjs = filter_projects(load_projects());
    my %queries = ();
    foreach my $p (values %$prjs) {
      my $uri = URI->new($p->{_remote}->{fetch});
      if ($uri->scheme eq 'ssh') {
        my $query = 'ssh';
        $query .= ' -p '.$uri->_port if defined $uri->_port;
        $query .= ' -l '.$uri->userinfo if defined $uri->userinfo;
        $query .= ' '.$uri->host;
        $query .= " gerrit query --patch-sets --format=JSON change:$change_id";
        $queries{$query} = 1;
      } else {
        push @$err, "unsupported remote ($uri) in $p->{name} for the download-id command";
      }
    }

    if (not %queries) {
      print_errors();
      print STDERR "error: no matching project found\n";
      exit (1);
    }

    my @changes = ();

    foreach my $query (keys %queries) {
      my @json = qx($query);
      foreach my $j (@json) {
        my $q = from_json($j);
        if (not defined $q) {
          push @$err, "gerrit did not return a JSON string but '$j'";
          next;
        }
        if (defined $q->{type} and $q->{type} eq 'error') {
          push @$err, "gerrit returned an error: '$q->{message}'";
          next;
        }
        next if defined $q->{type} and $q->{type} eq 'stats';
        if (not defined $q->{project} or not defined $q->{id}
            or not defined $q->{patchSets} or not defined $q->{number}
            or not defined $q->{branch}) {
          push @$err, "the query result seems to be no change '$j'";
          next;
        }

        push @changes, $q;
      }
    }

    print_errors(exit => 128);

    if (not @changes) {
      print STDERR "no changes for id $change_id found\n";
      exit(0);
    }

    my $prjs2 = filter_projects($prjs, [ map { $_->{project} } @changes ]);
    if (not %$prjs2) {
      print STDERR "no matching projects for id $change_id found\n";
      print STDERR "given projects: ".join(' ', sort keys %$prjs)."\n";
      print STDERR "prjs w/ change: ".join(' ', sort map { $_->{project} } @changes)."\n";
      exit(1);
    }

    $prjs = $prjs2;

    print "found change $change_id in the following projects:\n". join(' ', sort keys %$prjs)."\n";
    my %get_change = ();
    foreach my $c (@changes) {
      my $x = { change => $c->{number}, patchset => 1, chg => $c };
      my $g = \$get_change{$c->{project}};
      $$g = [] unless defined $$g;
      foreach my $p (@{$c->{patchSets}}) {
        $x->{ps} = $p->{number} if $x->{patchset} < $p->{number};
      }
      push @$$g, $x;
    }

    my $branch = $opts->{branch};
    while (my ($pn, $c) = each %get_change) {
      $c = [ grep { $_->{chg}->{branch} eq $branch } @$c ] if defined $branch;
      if (scalar(@$c) > 1) {
        push @$err, "$pn: $change_id is ambiguous, exists for ". join(', ', map { $_->{chg}->{branch} } @$c);
      }
      $get_change{$pn} = $$c[0];
    }

    print_errors(exit => 128);

    return fetch_and_co_changes($opts, $prjs, \%get_change);
  }
));

$commands->alias('cherry-pick-id' => 'download-id -c');
$commands->alias('merge-id' => 'download-id -p');


###### diff ####################################
$commands->add(diff => Subcommand->new(
  syn => [
    '%c %o [<commit>][..|...| ][<commit>] -- [<project>...]',
    { extra_args => 1 },
  ],
  desc => qq|Create a diff including all given projects.\r
             the <commit> parameters are equvalent to the parameters for git diff.
             However, there is the special commit {UPSTREAM} that corresponds to the
             revision that is specified in the manifest file.|,

  cmd => sub {
    my ($opts, $command, $cmd) = @_;
    my @args = @ARGV;
    foreach_repo(sub {
        my $prj = shift;
        my $git = $prj->git;
        #print "$prj->{name}\n";

        my $upstream = "refs/remotes/$prj->{_remote}->{name}/$prj->{revision}";
        my @a = @ARGV;
        s,\{UPSTREAM\},$upstream,g foreach @a;

        $git->run('diff',
                  '--src-prefix='.File::Spec->catdir('a', $prj->{path}).'/',
                  '--dst-prefix='.File::Spec->catdir('b', $prj->{path}).'/',
                  @a, '--', sub { print "$_\n";} );
        return 0;
    }, $opts->{__EXTRA_ARGS});
  }
));


## the main program #####################################
exit($commands->run($prog));


### git commit-msg hook for adding Change IDs #############################
sub gerrit_commit_msg_hook()
{
return <<'EOF';
#!/bin/sh
# From Gerrit Code Review 2.8.1
#
# Part of Gerrit Code Review (http://code.google.com/p/gerrit/)
#
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

unset GREP_OPTIONS

CHANGE_ID_AFTER="Bug|Issue"
MSG="$1"

# Check for, and add if missing, a unique Change-Id
#
add_ChangeId() {
	clean_message=`sed -e '
		/^diff --git a\/.*/{
			s///
			q
		}
		/^Signed-off-by:/d
		/^#/d
	' "$MSG" | git stripspace`
	if test -z "$clean_message"
	then
		return
	fi

	if test "false" = "`git config --bool --get gerrit.createChangeId`"
	then
		return
	fi

	# Does Change-Id: already exist? if so, exit (no change).
	if grep -i '^Change-Id:' "$MSG" >/dev/null
	then
		return
	fi

	id=`_gen_ChangeId`
	T="$MSG.tmp.$$"
	AWK=awk
	if [ -x /usr/xpg4/bin/awk ]; then
		# Solaris AWK is just too broken
		AWK=/usr/xpg4/bin/awk
	fi

	# How this works:
	# - parse the commit message as (textLine+ blankLine*)*
	# - assume textLine+ to be a footer until proven otherwise
	# - exception: the first block is not footer (as it is the title)
	# - read textLine+ into a variable
	# - then count blankLines
	# - once the next textLine appears, print textLine+ blankLine* as these
	#   aren't footer
	# - in END, the last textLine+ block is available for footer parsing
	$AWK '
	BEGIN {
		# while we start with the assumption that textLine+
		# is a footer, the first block is not.
		isFooter = 0
		footerComment = 0
		blankLines = 0
	}

	# Skip lines starting with "#" without any spaces before it.
	/^#/ { next }

	# Skip the line starting with the diff command and everything after it,
	# up to the end of the file, assuming it is only patch data.
	# If more than one line before the diff was empty, strip all but one.
	/^diff --git a/ {
		blankLines = 0
		while (getline) { }
		next
	}

	# Count blank lines outside footer comments
	/^$/ && (footerComment == 0) {
		blankLines++
		next
	}

	# Catch footer comment
	/^\[[a-zA-Z0-9-]+:/ && (isFooter == 1) {
		footerComment = 1
	}

	/]$/ && (footerComment == 1) {
		footerComment = 2
	}

	# We have a non-blank line after blank lines. Handle this.
	(blankLines > 0) {
		print lines
		for (i = 0; i < blankLines; i++) {
			print ""
		}

		lines = ""
		blankLines = 0
		isFooter = 1
		footerComment = 0
	}

	# Detect that the current block is not the footer
	(footerComment == 0) && (!/^\[?[a-zA-Z0-9-]+:/ || /^[a-zA-Z0-9-]+:\/\//) {
		isFooter = 0
	}

	{
		# We need this information about the current last comment line
		if (footerComment == 2) {
			footerComment = 0
		}
		if (lines != "") {
			lines = lines "\n";
		}
		lines = lines $0
	}

	# Footer handling:
	# If the last block is considered a footer, splice in the Change-Id at the
	# right place.
	# Look for the right place to inject Change-Id by considering
	# CHANGE_ID_AFTER. Keys listed in it (case insensitive) come first,
	# then Change-Id, then everything else (eg. Signed-off-by:).
	#
	# Otherwise just print the last block, a new line and the Change-Id as a
	# block of its own.
	END {
		unprinted = 1
		if (isFooter == 0) {
			print lines "\n"
			lines = ""
		}
		changeIdAfter = "^(" tolower("'"$CHANGE_ID_AFTER"'") "):"
		numlines = split(lines, footer, "\n")
		for (line = 1; line <= numlines; line++) {
			if (unprinted && match(tolower(footer[line]), changeIdAfter) != 1) {
				unprinted = 0
				print "Change-Id: I'"$id"'"
			}
			print footer[line]
		}
		if (unprinted) {
			print "Change-Id: I'"$id"'"
		}
	}' "$MSG" > "$T" && mv "$T" "$MSG" || rm -f "$T"
}
_gen_ChangeIdInput() {
	echo "tree `git write-tree`"
	if parent=`git rev-parse "HEAD^0" 2>/dev/null`
	then
		echo "parent $parent"
	fi
	echo "author `git var GIT_AUTHOR_IDENT`"
	echo "committer `git var GIT_COMMITTER_IDENT`"
	echo
	printf '%s' "$clean_message"
}
_gen_ChangeId() {
	_gen_ChangeIdInput |
	git hash-object -t commit --stdin
}


add_ChangeId

EOF
}
