#! /usr/bin/perl -w

use strict;
use warnings;

BEGIN {
  use File::Basename qw(dirname);
  use Cwd qw(realpath);
  if (__FILE__ =~ /^\//) {
    push @INC, dirname(realpath(__FILE__));
  }
}

use Hammer::Process_queue;
use Hammer::Subcommand;
use Hammer::Project;

use XML::Simple;
use File::Spec::Functions qw(catdir);
use File::Spec;
use File::Path qw(make_path);
use URI;
use IO::Select;
use Cwd;
use JSON;

my $prog = 'ham';

my $user_config = File::Spec->catdir($ENV{HOME}, ".hamconfig");

if (-t STDOUT) {
  eval { require Term::ANSIColor };
  if (!$@) {
    import Term::ANSIColor qw(colored);
  } else {
    *colored = sub { return $_[0]; }
  }
} else {
  *colored = sub { return $_[0]; }
}

sub pager
{
  if (-t STDOUT and $ENV{PAGER}) {
    my $out;
    return $out if open $out, "|$ENV{PAGER}";
  }
  return *STDOUT;
}

sub filter_projects
{
  my ($projects, $argv) = @_;
  $argv = \@ARGV unless defined $argv;

  if (defined $argv->[0]) {
    my %r = ();
    my $inverse = 0;
    my @args = @$argv;

    if ($args[0] eq '!') {
      shift @args;
      $inverse = 1;
      %r = %{$projects};
    }

    foreach my $n (@args) {
      if (exists $projects->{$n}) {
        if (not $inverse) {
          $r{$n} = $projects->{$n};
        } else {
          delete $r{$n};
        }
        next;
      }

      # handle '.' magic, find out project is the best hitfor
      # the current working directory
      if ($n eq '.') {
        my $cwd = getcwd;
        my $hit_p = '';
        my $hit;
        foreach my $p (values %$projects) {
          my $path = $p->abs_path;
          if ($cwd =~ /^$path(\/+|$)/ and length $path > length $hit_p) {
            $hit_p = $path;
            $hit = $p;
          }
        }

        if (defined $hit) {
          if (not $inverse) {
            $r{$hit->{name}} = $hit;
          } else {
            delete $r{$hit->{name}};
          }
        }
      }
    }
    return \%r;
  }
  return $projects;
}

sub project_for_path
{
  my ($projects, $path) = @_;
  my $rb = realpath(repo_base());
  my $current_prj;
  my @prj_rel;
  foreach my $p (values %$projects) {
    my $prj_base = realpath(File::Spec->catdir($rb, $p->{path}));
    my $rel = File::Spec->abs2rel(realpath($path), $prj_base);
    my @rel = File::Spec->splitdir($rel);
    next unless @rel;
    next if $rel[0] eq '..'; # different project
    if (not $current_prj or scalar(@rel) < scalar(@prj_rel)) {
      $current_prj = $p;
      @prj_rel = @rel;
    }
  }
  return ($current_prj, File::Spec->catdir(@prj_rel));
}


###### the main command (no command given) ############################
my $commands = Hammer::Subcommand->new(
  cmd  => sub { $_[2]->print_usage($_[1], pager); },
  syn  => '%c',
  desc => 'print help'
);

$commands->add(help => {
  cmd => sub {
    if (@ARGV) {
      my ($ok, $cmd, $command, $sub) = $commands->find($prog);
      if ($ok) {
        $cmd->print_usage($command, pager);
      } else {
        print STDERR "error: unknown command $command $sub\n";
        $cmd->print_usage($command, *STDERR);
      }
    }
    $commands->print_usage($prog, pager);
  },
  syn => '%c',
  desc => 'print help'
});


my $repo_dir;
my $repo_base;
my $repo_subdir = '.ham';

sub get_repo_dir
{
  my $try = shift;
  return $repo_dir if defined $repo_dir;
  my $cwd = getcwd;

  my ($vol, $dirs, $file) = File::Spec->splitpath($cwd, no_file => 1);
  my @dirs = File::Spec->splitdir($dirs);

  while (1) {
    my $d = File::Spec->catpath($vol, File::Spec->catdir(@dirs, $repo_subdir), '');
    if (-d $d) {
      $repo_dir = $d;
      $repo_base = File::Spec->catpath($vol, File::Spec->catdir(@dirs), '');
      return $repo_dir;
    }

    return undef if not @dirs and $try;
    die "not in $prog repo directory (could not find $repo_subdir)\n" unless @dirs;
    pop @dirs;
  }
}

sub repo_base
{
  get_repo_dir(@_);
  return $repo_base;
}

sub repo_manifest() { get_repo_dir().'/manifest.xml' }
sub repo_config() { get_repo_dir().'/config' }

my $info = [];
my $err  = [];

##########################################################################

my @project_attrs = ('revision', 'remote');

sub apply_default
{
  my ($manifest, $r, $what) = @_;
  $r->{$what} = $manifest->{default}->{$what} unless defined $r->{$what};
}

sub load_projects
{
  my $file = shift;
  $file = repo_manifest();
  open my $mf, "<".get_repo_dir().'/manifests_url';
  my $manifest_url = <$mf>;
  close $mf;
  chomp($manifest_url);
  $manifest_url = URI->new($manifest_url);
  my $manifest = XMLin($file,
    ForceArray => ['project', 'remote'],
    KeyAttr => { project => "+name", remote => "+name" });

  my $projects = $manifest->{project};
  foreach my $r (values %$projects) {
    foreach my $attr (@project_attrs) {
      apply_default($manifest, $r, $attr);
    }

    $r->{_remote} = $manifest->{remote}->{$r->{remote}};
    $r = Hammer::Project->new($r, root => repo_base(), stderr => $err, stdout => $info);
  }

  foreach my $r (values %{$manifest->{remote}}) {
    $r->{fetch} = URI->new_abs($r->{fetch}, $manifest_url)->as_string;
    $r->{review} = URI->new_abs($r->{review}, $manifest_url)->as_string;
  }
  return $projects;
}

##########################################################################

sub foreach_prj_r
{
  my ($func, $projects) = @_;
  foreach my $r (@$projects) {
    local $_ = $r;
    my $res = $func->($r);
    return $res if $res;
  }
  0;
}

sub print_errors
{
  my %opts = @_;
  foreach my $i (@$info) {
    print "$i\n";
  }

  $info = [];

  my $errpfx = defined $opts{no_prefix} ? '' : 'error: ';
  foreach my $e (@$err) {
    print STDERR "$errpfx$e\n";
  }

  if ($opts{err_msg} and @$err) {
    print STDERR "$opts{err_msg}\n";
  }

  if ($opts{exit} and @$err) {
    exit($opts{exit});
  }

  if ($opts{err_val} and @$err) {
    $err = [];
    return $opts{err_val};
  }
  $err = [];

  return 0;
}

sub sorted_and_filtered_projects
{
  my ($prjs) = @_;
  $prjs = \@ARGV unless defined $prjs;
  my $projects = filter_projects(load_projects(), $prjs);
  return [ sort { $a->{name} cmp $b->{name} } values %$projects ];
}

sub foreach_prj(&@)
{
  my ($func, $prjs) = @_;
  $prjs = \@ARGV unless defined $prjs;

  my $res = foreach_prj_r($func, sorted_and_filtered_projects($prjs));
  print_errors();
  return $res;
}

####### list projects #################################
$commands->add(list => {
  cmd  => sub { foreach_prj { print "$_->{name} $_->{path}\n"; 0; }; },
  syn  => '%c',
  desc => "list all projects managed by $prog"
});


###### initialize managed directory ####################

sub place_commit_msg_hook
{
  my $d = get_repo_dir();
  make_path("$d/hooks") unless -d "$d/hooks";
  open my $cm, ">$d/hooks/commit-msg"
    or die "fatal: could not open $d/hooks/commit-msg for writing: $!\n";

  print $cm gerrit_commit_msg_hook();
  close $cm;
  chmod 0755, "$d/hooks/commit-msg";
}

sub manifest_prj
{
  my ( $url, %opts ) = @_;
  my $p = {
    name => '',
    path => "$repo_subdir/manifests",
    remote => 'origin',
    _remote => { name => 'origin', fetch => $url, review => $url },
    revision => $opts{revision},
  };
  $p->{revision} = 'master' unless $p->{revision};
  my $r = $opts{root};
  $r = repo_base() unless $r;
  return Hammer::Project->new($p, root => $r, stderr => $err, stdout => $info);
}

###### init #############################################
$commands->add(init => {
  cmd => \&cmd_init,
  syn => [
    '%c %o',
    [ 'url|u=s',    'URL of the manifest repository',    { arg => '<manifest url>' } ],
    [ 'file|f|m=s', 'set the name of the manifest file', { arg => '<manifest>' } ],
  ],
  desc => "initialize $prog meta project in the curent directory"
});

sub cmd_init
{
  my ($opt, $command, $cmd) = @_;
  my $repo_dat_src = $opt->{file};
  my $repodir = get_repo_dir(1);
  if (defined $repodir and -f File::Spec->catdir($repodir, 'manifests_url')) {
    open my $mf, "<".get_repo_dir().'/manifests_url' or die "cannot open manifest_url file: $!";
    my $manifest_url = <$mf>;
    close $mf;
    chomp $manifest_url;
    my $new_url = $opt->{url};
    die "fatal: reinitializing ham directory without URL" if not defined $new_url;
    die "fatal: ham directory already initialized for different URL $manifest_url" if $manifest_url ne $new_url;
    print STDERR "warning: ham directory already initialized\n";
    return 0;
  } elsif (defined $repodir) {
    print STDERR "fatal: half initialized ham directory, please cleanup\n";
    exit(128);
  }

  $repo_dir = $repo_subdir;
  place_commit_msg_hook();
  if (defined $opt->{url}) {
    # try to download a manifest repo
    $repo_dat_src = 'default.xml' unless defined $repo_dat_src;
    #mkdir($repo_subdir);
    my $manifest = manifest_prj($opt->{url}, root => '.');
    my $q = Hammer::Process_queue->new();
    $q->queue(sub { $manifest->sync; });
    $q->work;
    print_errors(exit => 128);
    print STDERR "Preparing manifest\n";
    $manifest->prepare();
    print_errors(exit => 128);
    symlink("manifests/$repo_dat_src", "$repo_subdir/manifest.xml");
    open my $u, ">$repo_subdir/manifests_url";
    print $u "$opt->{url}\n";
    close $u;
  } else {
    # use a local file as manifest and copy it
    my $repo_dat = repo_manifest();
    die "error: you need to specify a manifest XML file\n" if not defined $repo_dat_src;
    die "error: $repo_dat_src is no readable file\n" if not (-f $repo_dat_src and -r $repo_dat_src);
    mkdir($repo_subdir);
    open my $rd, ">$repo_dat" or die "error: cannot open $repo_dat: $!\n";
    open my $rs, "<$repo_dat_src" or die "error: cannot open $repo_dat_src: $!\n";
    while (<$rs>) { print $rd $_; }
    close $rs;
    close $rd;
  }

  return 0;
}


###### sync ###########################################
$commands->add(sync => {
  cmd  => \&cmd_sync,
  syn  => [
    '%c [<project>...]',
    [ 'rebase',   q|rebase the current branch onto the
                    corresponging branch in the projects remote| ],
    [ 'upstream', q|checkout theupstream revisions as defined in
                    the manifest| ],
  ],
  desc => 'checkout/update all projects'
});

sub cmd_sync
{
  my ($opts, $command, $cmd) = @_;
  # update manifest repo, if there is any
  if (-d get_repo_dir().'/manifests/.git') {
    my $r = Git::Repository->new(work_tree => get_repo_dir().'/manifests',
                                 { env => { LC_ALL => 'C' } });
    $r->run(pull => 'origin');
  }
  place_commit_msg_hook();

  my $projects = sorted_and_filtered_projects(\@ARGV);
  my $q = Hammer::Process_queue->new();

  foreach my $r (@$projects) { $q->queue(sub { $r->sync; }); }
  $q->work;

  print_errors(exit => 128);
  print STDERR "Preparing gits .....................\n";

  $_->prepare($opts) foreach @$projects;
  print_errors(exit => 128);

  return 0;
}


###### status #########################################
$commands->add(status => {
  syn  => [
    '%c %o [<project>...]',
    [ 'short|s',     'generate output in git short mode' ],
    [ 'branch|b',    'show branch information event in short mode' ],
    [ 'porcelain', q|generate output in short mode and with
                     branch infos and without any colors|]
  ],
  desc => 'show the status of all projects',
  cmd  => sub {
    my ($opts, $command, $cmd) = @_;

    if ($opts->{porcelain}) {
      foreach_prj { $_->print_status; 0;}
      return 0;
    }

    select pager;
    my $branch_info = 1;
    my $short = $opts->{short};
    $branch_info = $opts->{branch} if $short;

    foreach_prj {
      my $p = $_;
      my $s = $p->status;
      return 0 unless $branch_info and $s->is_different or $s->is_dirty;
      print colored("project: $p->{name}: ".$p->abs_path, 'bold'), "\n";
      if ($branch_info) {
        print "    $s->[0]\n";
      }
      if ($short) {
        print "    $_\n" foreach $s->files;
      } else {
        sub show
        {
          my ($msg, @i) = @_;
          if (@i) {
            print "\n$msg:\n";
            print "\t".colored($_, 'red')."\n" foreach @i;
          }
        }

        show("Files with merge conflicts", $s->pretty_conflicts($p->{path}));
        show("Changes staged for commit", $s->pretty_index($p->{path}));
        show("Changes not staged for commit", $s->pretty_changed($p->{path}));
        show("Untracked files", $s->pretty_untracked($p->{path}));
        print "\n";
      }
      return 0;
    };

    return 0;
  }
});


###### forall #######################################
$commands->add(forall => {
  cmd => \&cmd_forall,
  syn => [
    '%c [<project>...] %o -- <cmd> [<arg>...]',
    { pre_args => 1 },
    [ 'abort-on-errors|e' , 'Abort if a command exits with an exitcode other than zero' ],
    [ 'p',                  'print project name before each execution of <cmd>' ],
    [ 'vars|i',           qq|prelace special '{...}' tokens within the arguments| ],
  ],
  desc => 'run <cmd> for all projects'
});

sub cmd_forall
{
  my ($opt, $cmd, $subs) = @_;
  my $print_prj = $opt->{p};

  if (not @ARGV) {
    $subs->print_usage($cmd);
  }

  my $cwd = getcwd;

  my $res = foreach_prj {
    my $r = $_;
    print colored("$r->{name}: $r->{path}\n", 'bold') if $print_prj;
    chdir $r->abs_path;
    my @argv = @ARGV;
    if ($opt->{vars}) {
      my $upstream = "refs/remotes/$r->{_remote}->{name}/$r->{revision}";
      s,\{UPSTREAM\},$upstream,g foreach @argv;
    }
    my $res = system(@argv);
    return ($res) if $res and $opt->{'abort-on-errors'};
    return 0;
  } $opt->{__PREARGS};

  chdir $cwd;
  return $res;
}


####### checkout ################################
$commands->add(checkout => {
  cmd  => \&cmd_checkout,
  syn  => [
    '%c <branch> [<project>...]',
    [ 'abort-on-errors|e', 'Abort on any error, otherwise all projects will be interated' ]
  ],
  desc => 'checkout <branch> in all projects'
});

sub cmd_checkout
{
  my ($opts, $command, $cmd) = @_;
  my $branch = shift @ARGV;
  $cmd->print_usage($command) unless defined $branch;
  my $abt = $opts->{'abort-on-errors'};
  return foreach_prj {
    my $r = $_->checkout($branch);
    return $r if $r and $abt;
    return 0;
  };
}


###### start a new topic branch ##################
$commands->add(start => {
  cmd => \&cmd_start,
  syn => [
    '%c %o <branch name> [<projects>...]',
    [ 'base|t=s', 'starting point for the new branch', { arg => '<start-point>' } ],
  ],
  desc => 'start a new topic branch <branch> in all projects'
});

sub cmd_start
{
  my $opt = shift;
  my $branch = shift @ARGV;

  $_[2]->print_usage($_[1]) unless defined $branch;
  my $base = $opt->{base};
  my @args = ('--track', '-b', $branch);
  push @args, $base if defined $base and $base ne '';

  return foreach_prj { $_->checkout(@args); 0;};
}


###### info ####################################
$commands->add(info => {
  cmd  => \&cmd_info,
  syn  => '%c [<project>...]',
  desc => 'show infos for each project'
});

sub cmd_info
{
  select pager;
  foreach_prj {
    my $p = $_;
    my $g = $p->git;
    my $head = $g->rev_parse('--abbrev-ref', 'HEAD');
    print colored("$p->{name}: in $p->{path}\n", 'bold');
    print "  remote: $p->{remote} @ branch ".colored($p->{revision}, 'yellow')."\n";
    print "  local revision: ".colored($head, 'yellow')."\n";
    my $s = $p->status;
    my $dirty = $s->is_dirty;
    print "  status: ".$s->branch_status."\n" if $s->is_different;
    print colored("          contains untracked files\n", 'red') if $s->untracked;
    print colored("          contains uncommited changes in the index\n", 'green') if $s->index;
    print colored("          contains modifications in the working copy\n", 'red') if $s->changed;
    print colored("          has merge conflicts\n", 'bold', 'red') if $s->conflicts;
    print "\n";
    0;
  };

  0;
}


###### remote #######################################
$commands->add(
  remote => {
    cmd => sub { $_[2]->print_usage($_[1]); 0; },
    syn => '%c',
    desc => 'manage remotes for all projects'
  }
);

###### remote add ####################################
sub cmd_remote_xxx
{
  my ($what, $x, $command, $cmd) = @_;
  my $name = shift @ARGV;
  $cmd->print_usage($command) unless defined $name;
  my $url = shift @ARGV;
  $cmd->print_usage($command) unless defined $url;
  $url .= '/' unless substr($url, -1, 1) eq '/';
  $url = URI->new($url);
  foreach_prj {
    my $r = $_;
    my $rurl = URI->new_abs($r->{name}, $url);
    #print $url, " => ", $rurl, "\n";
    $r->git->run(remote => $what, $name, $rurl->as_string);
    0;
  };
  return 0;
}

$commands->sub->{remote}->add(
  add => {
    syn  => '%c <remote-name> <url> [<project>...]',
    desc => 'add a repository remote for to each git repo using <url> as prefix',
    cmd  => sub { cmd_remote_xxx('add', @_) }
  }
);

$commands->sub->{remote}->add(
  'set-url' => {
    syn  => '%c <remote-name> <url> [<project>...]',
    desc => 'set the url for each git repo using <url> as prefix',
    cmd  => sub { cmd_remote_xxx('set-url', @_) }
  }
);


sub approve_dependent_changes
{
  my ($prj, $commits) = @_;
  print STDERR "project $prj->{name} ($prj->{path}) has more than one change,\n".
               "this will produce the following dependent changes:\n\n";
  my @log = $prj->bare_git->run('log', '--color=always', '--oneline', "$$commits[$#$commits]~1..$$commits[0]");

  print STDERR "$_\n" foreach (@log);
  print STDERR "\ndo you want to upload these changes at once? [y/N]: ";
  my $answer = <STDIN>;
  chomp $answer;
  return $answer eq 'y' or $answer eq 'Y' or $answer eq 'yes';
}

###### upload ####################################################
$commands->add(upload => {
  cmd => \&cmd_upload,
  syn => [
    '%c %o [<project>...]',
    { config => [ 'no_ignore_case' ] },
    [ 'draft|d',         'submit as draft' ],
    [ 't',               'Use branch name as topic' ],
    [ 'topic=s',         'Set <topic> as topic', { arg => '<topic>' } ],
    [ 're|reviewers=s@', q|Add reviewers. This option takes a comma separated
                           list of reviewers and may be supplied more than once|, { arg => '<reviewer>' } ],
    [ 'cc=s@',           q|Add email addresses for CC. This option takes a comma
                           separated list of email addresses and may be supplied
                           multiple times|,                                       { arg => '<cc-email>' } ],
    [ 'br=s',            'Upload <local branch> for review',                      { arg => '<local-branch>' } ],
    [ 'dest|destination|D=s', 'Upload commit for destination branch',             { arg => '<branch>' } ],
    [ 'dry-run|n',       'Do a dry run, just print the git commands that would be issued' ],
  ],
  desc => 'upload changes for review'
});

sub cmd_upload
{
  my $opts = shift;
  $opts->{br} = 'HEAD' unless defined $opts->{br};

  my $projects = sorted_and_filtered_projects(\@ARGV);

  my @warn;
  my @good_projects;

  foreach my $prj (@$projects) {
    my ($upload, $src_br, $dst_br)
      = $prj->check_for_upload(\@warn, $opts->{br}, $opts->{dest},
                               \&approve_dependent_changes);

    push @good_projects, [ $prj, $src_br, $dst_br ] if $upload;
  }

  if (@$err) {
    print_errors();
    print STDERR "Aborting\n";
    return 1;
  }

  if (@warn) {
    foreach my $w (@warn) {
      print "warning: $w\n";
    }
  }

  if (not @good_projects) {
    print "nothing to do for this upload\n";
    return 0;
  }

  # everything is checked, so start upload
  print "upload changes to ".scalar(@good_projects)." project(s):";
  foreach my $prj (@good_projects) {
    print " $prj->[0]->{name}";
  }
  print "\n";

  my @base_attr;
  foreach my $c (map { split /,/ } @{$opts->{re}}) {
    push @base_attr, "r=$c";
  }

  foreach my $c (map { split /,/ } @{$opts->{cc}}) {
    push @base_attr, "cc=$c";
  }

  my $target = 'for';
  $target = 'drafts' if ($opts->{draft});

  foreach my $p (@good_projects) {
    my ($prj, $src_br, $dst_br) = @$p;
    my $dst_ref = catdir('refs', $target, $dst_br);
    my @attrs;
    my $r = $prj->bare_git;
    if ($opts->{topic}) {
      push @attrs, "topic=$opts->{topic}";
    } elsif ($opts->{t}) {
      $src_br = $r->rev_parse('--abbrev-ref', $src_br) if $src_br eq 'HEAD';
      push @attrs, "topic=$src_br";
    }
    push @attrs, @base_attr;
    if (@attrs) {
      $dst_ref .= "%".join(',', @attrs);
    }

    if ($opts->{'dry-run'}) {
      print "$prj->{path}: git push $prj->{remote} $src_br:$dst_ref\n";
    } else {
      push @$info, $r->run('push', $prj->{remote}, "$src_br:$dst_ref");
    }
  }

  return 0;
}


##############################################################
sub fetch_and_co_changes
{
  my ($opts, $prjs, $changes) =  @_;

  my $q = Hammer::Process_queue->new();
  foreach my $prj (values %$prjs) {
    my $remote_name = $prj->{_remote}->{name};
    my $c = $changes->{$prj->{name}};
    my $change = $c->{change};
    my $patchset = $c->{patchset};

    $q->queue(sub { $prj->fetch($remote_name, sprintf("refs/changes/%02d/%d/%d", ($change % 100), $change, $patchset)); });
  }

  $q->work;

  print_errors(exit => 128);

  my $action;
  my @log;

  if (defined $opts->{pull}) {
    $action = sub {
      my $git = $_[0]->git;
      my $head = $git->rev_parse('--abbrev-ref', 'HEAD');
      push @$info, $git->run('merge', 'FETCH_HEAD');
      push @log, [ $_[0], "merged %c/%p into $head" ];
    };
  } elsif (defined $opts->{'cherry-pick'}) {
    $action = sub {
      my $git = $_[0]->git;
      my $head = $git->rev_parse('--abbrev-ref', 'HEAD');
      push @$info, $git->run('cherry-pick', 'FETCH_HEAD');
      push @log, [ $_[0], "cherry picked %c/%p onto $head" ];
    };
  } else {
    $action = sub {
      my $git = $_[0]->git;
      $_[0]->checkout('--detach', '-q', 'FETCH_HEAD');
      push @log, [ $_[0], "checked out %c/%p as detached HEAD" ];
    };
  }

  foreach my $prj (values %$prjs) {
    $action->($prj);
  }

  my $res = print_errors(err_val => 128);

  print "changes:\n";
  foreach my $log (sort { $a->[0]->{name} cmp $b->[0]->{name} } @log) {
    my $prj = $log->[0];
    my $msg = $log->[1];
    my $remote_name = $prj->{_remote}->{name};
    my $c = $changes->{$prj->{name}};
    my $change = $c->{change};
    my $patchset = $c->{patchset};
    #my $rev = $c->{chg}{currentPatchSet}{revision};

    $msg =~ s,%c,$change,g;
    $msg =~ s,%p,$patchset,g;
    #$msg =~ s,%r,$rev,g;

    print "  $prj->{name} [$remote_name]: $msg\n";
  }

  return $res;
}


###### download ####################################
$commands->add(download => {
  syn => [
    '%c %o <project> <change-nr>[/<patchset>]',
    [ 'cherry-pick|cp|c',  q|Cherry pick the change onto the current branch
                             instead of checking out the change| ],
    [ 'pull|p',            q|Pull (merge) the change into the current branch|],
    [ 'remote|r=s',        q|Use <remote> as git remote to fetch the change,
                             instead of using the remote configured in the manifest.|,
                           { arg => '<remote>' } ]
  ],
  desc => q|Download a change for the given project into your local working copy|,
  cmd => sub {
    my ($opts, $command, $cmd) = @_;
    my ($prjn, $change) = @ARGV;
    $cmd->usage_error($command, 'error: missing prject name') unless defined $prjn;
    my $prj = filter_projects(load_projects(), [ $prjn ])->{$prjn};
    $cmd->usage_error($command, "error: unknown project $prjn") unless defined $prj;
    $cmd->usage_error($command, "error: missing change number") unless defined $change;
    my $patchset = 1;
    if ($change =~ /^([0-9]+)(?:\/([0-9]+))?$/) {
      $change = $1;
      $patchset = $2 if defined $2;
    } else {
      $cmd->usage_error($command, "error: invalid change/patchset format '$change'");
    }

    return fetch_and_co_changes($opts,
      { $prjn => $prj },
      { $prjn => { change => $change, patchset => $patchset }}
    );
  }
});


###### download-id ####################################
$commands->add('download-id' => {
  syn => [
    '%c %o <change-id> [<project>...]',
    [ 'cherry-pick|cp|c',  q|Cherry pick the change onto the current branch
                             instead of checking out the change| ],
    [ 'pull|p',            q|Pull (merge) the change into the current branch|],
    [ 'branch|b=s',        q|Get the change for the specified branch, usually
                             any matching change will be downloaded as long as
                             there is no ambiguity.|, { arg => '<branch>' } ],
  ],
  desc => q|Download all changes for all projects with the given change ID (Change-Id)
            to your local working copy|,
  cmd => sub {
    my ($opts, $command, $cmd) = @_;
    my $change_id = shift @ARGV;
    $cmd->usage_error($command, "error: missing change id") unless defined $change_id;

    my $all_prjs = filter_projects(load_projects());
    my %change_ids = ( $change_id => 1 );
    my $recurse = 0;

    while (1) {
    my $prjs = $all_prjs;

    my %queries = ();
    foreach my $p (values %$prjs) {
      foreach my $chid (keys %change_ids) {
        next if not $change_ids{$chid};
        my $uri = URI->new($p->{_remote}->{fetch});
        if ($uri->scheme eq 'ssh') {
          my $query = 'ssh';
          $query .= ' -p '.$uri->_port if defined $uri->_port;
          $query .= ' -l '.$uri->userinfo if defined $uri->userinfo;
          $query .= ' '.$uri->host;
          $query .= " gerrit query --current-patch-set --format=JSON change:$chid";
          $queries{$query} = 1;
        } else {
          push @$err, "unsupported remote ($uri) in $p->{name} for the download-id command";
        }
      }
    }

    if (not %queries) {
      print_errors();
      print STDERR "error: no matching project found\n";
      exit (1);
    }

    my @changes = ();

    foreach my $query (keys %queries) {
      my @json = qx($query);
      foreach my $j (@json) {
        my $q = from_json($j);
        if (not defined $q) {
          push @$err, "gerrit did not return a JSON string but '$j'";
          next;
        }
        if (defined $q->{type} and $q->{type} eq 'error') {
          push @$err, "gerrit returned an error: '$q->{message}'";
          next;
        }
        next if defined $q->{type} and $q->{type} eq 'stats';
        if (not defined $q->{project} or not defined $q->{id}
            or not defined $q->{currentPatchSet} or not defined $q->{number}
            or not defined $q->{branch}) {
          push @$err, "the query result seems to be no change '$j'";
          next;
        }

        push @changes, $q;
      }
    }

    print_errors(exit => 128);

    if (not @changes) {
      print STDERR "no changes for id ".join(' ',keys %change_ids)." found\n";
      exit(0);
    }

    my $prjs2 = filter_projects($prjs, [ map { $_->{project} } @changes ]);
    return 0 if not %$prjs2 and $recurse;

    if (not %$prjs2) {
      print STDERR "no matching projects for id $change_id found\n";
      print STDERR "given projects: ".join(' ', sort keys %$prjs)."\n";
      print STDERR "prjs w/ change: ".join(' ', sort map { $_->{project} } @changes)."\n";
      exit(1);
    }

    $prjs = $prjs2;

    print "found change $change_id in the following projects:\n". join(' ', sort keys %$prjs)."\n";
    my %get_change = ();
    foreach my $c (@changes) {
      next if not $c->{open};
      next if not $prjs->{$c->{project}};
      my $x = { change => $c->{number}, patchset => 1, chg => $c };
      my $g = \$get_change{$c->{project}};
      $$g = [] unless defined $$g;
      $x->{patchset} = $c->{currentPatchSet}{number};
      push @$$g, $x;
    }

    my $branch = $opts->{branch};
    while (my ($pn, $c) = each %get_change) {
      $c = [ grep { $_->{chg}->{branch} eq $branch } @$c ] if defined $branch;
      if (scalar(@$c) > 1) {
        push @$err, "$pn: $change_id is ambiguous, exists for ". join(', ', map { $_->{chg}->{branch} } @$c);
      }
      $get_change{$pn} = $$c[0];
    }

    print_errors(exit => 128);

    my $r = fetch_and_co_changes($opts, $prjs, \%get_change);

    return $r if $r;

    foreach my $prj_name (keys %get_change) {
      my $c = $get_change{$prj_name};
      my $p = $prjs->{$prj_name};
      my $revs = $p->git->run('rev-list', '^'.$p->{revision}, 'HEAD', '--');
      my $cmd = $p->git->command('cat-file', '--batch', { input => "$revs\n" });
      foreach my $chid (grep { s/^Change-Id:\s+(\S+)/$1/ } $cmd->final_output) {
        if (defined $change_ids{$chid}) {
          delete $change_ids{$chid};
        } else {
          $change_ids{$chid} = 1;
        }
      }
    }

    if (%change_ids) {
      $all_prjs = filter_projects($all_prjs, [ '!', (keys %get_change) ]);
      $recurse = 1;
    } else {
      return $r;
    }
  }

    return 0;
  }
});


###### diff ####################################
$commands->add(diff => {
  syn => [
    '%c %o [<commit>][..|...| ][<commit>] -- [<project>...]',
    { extra_args => 1, config => [ 'pass_through' ] },
  ],
  desc => qq|Create a diff including all given projects.\r
             the <commit> parameters are equvalent to the parameters for git diff.
             However, there is the special commit {UPSTREAM} that corresponds to the
             revision that is specified in the manifest file.|,

  cmd => sub {
    my ($opts, $command, $cmd) = @_;
    my @args = @ARGV;
    select pager;
    foreach_prj {
        my $prj = $_;
        my $git = $prj->git;
        #print "$prj->{name}\n";

        my $upstream = "refs/remotes/$prj->{_remote}->{name}/$prj->{revision}";
        my @a = @ARGV;
        s,\{UPSTREAM\},$upstream,g foreach @a;

        $git->run('diff',
                  '--src-prefix='.File::Spec->catdir('a', $prj->{path}).'/',
                  '--dst-prefix='.File::Spec->catdir('b', $prj->{path}).'/',
                  @a, '--', sub { print "$_\n";} );
        return 0;
    } $opts->{__EXTRA_ARGS};
  }
});

###### rev-list ####################################
$commands->add('rev-list' => {
  syn => [
    '%c %o [<revisions>...] -- [<project>...]',
    { extra_args => 1, config => [ 'pass_through' ] },
  ],
  desc => qq|Print a git rev-list for each project.\r
             The rev-list for ech project is printed on a single line
             with the following layout:\r
             <project name>: SP <rev> SP ...|,
  cmd => sub {
    my ($opts, $command, $cmd) = @_;
    foreach_prj {
      my $prj = $_;
      my $git = $prj->git;
      #print "$prj->{name}\n";

      my $upstream = "refs/remotes/$prj->{_remote}->{name}/$prj->{revision}";
      my @a = @ARGV;
      s,\{UPSTREAM\},$upstream,g foreach @a;

      my @revs = $git->run('rev-list', @a, '--');
      print "$prj->{name}: ".join(' ', @revs)."\n" if @revs;
      return 0;
    } $opts->{__EXTRA_ARGS};
  }
});

###### log ####################################
$commands->add('log' => {
  syn => [
    '%c %o [<revision>...] -- [<project>...]',
    { extra_args => 1, config => [ 'pass_through' ] },
  ],
  desc => qq|Print a git log for each project.|,
  cmd => sub {
    my ($opts, $command, $cmd) = @_;
    select pager;
    foreach_prj {
      my $prj = $_;
      my $git = $prj->git;

      my $upstream = "refs/remotes/$prj->{_remote}->{name}/$prj->{revision}";
      my @a = @ARGV;
      s,\{UPSTREAM\},$upstream,g foreach @a;

      my $first = 1;
      my @revs = $git->run('log', '--color=always', @a, '--', sub {
          if ($first) {
            $first = 0;
            print "$prj->{name}: $prj->{path}\n";
          }
          print "  $_\n";
        });

      print "\n" unless $first;

      return 0;
    } $opts->{__EXTRA_ARGS};
  }
});

###### commit ####################################
sub get_160bit_rnd
{
  my $rnd;
  open my $rnd_file, "</dev/urandom";
  read $rnd_file, $rnd, 20;
  close $rnd_file;
  return (unpack('H*', $rnd))[0];
}

sub split_message
{
  my @msg = @_;

  my $attachment;
  my $footer;

  my $footer_comment = 0;
  my $blank_lines = 0;
  my $p = \@msg;

  local $_;

  for (my $l = 0; $l < scalar(@msg); $l++) {
    local $_ = $msg[$l];
    #put comments into the current part
    if (/^#/) {
      $l -= $blank_lines - 1;
      splice(@msg, $l, $blank_lines - 1) if $blank_lines > 1;
      $blank_lines = 0;
      $footer = $l if not $footer;
      $footer_comment = 0;
      next;
    }

    # put all text starting from a diff line into the last part of the message
    if (m|^diff --git a/|) {
      if ($blank_lines) {
        $l -= $blank_lines - 1;
        splice(@msg, $l, $blank_lines - 1) if $blank_lines > 1;
        $blank_lines = 0;
      }
      $attachment = $l;
      last;
    }

    if (/^$/ and not $footer_comment) {
      $blank_lines++;
      next;
    }

    $footer_comment = 1 if /^\[[a-zA-Z0-9-]+:/ and defined $footer;
    $footer_comment = 2 if /]$/ and $footer_comment == 1;

    if ($blank_lines) {
      $l -= $blank_lines - 1;
      splice(@msg, $l, $blank_lines - 1) if $blank_lines > 1;
      $blank_lines = 0;
      $footer = $l if not $footer;
      $footer_comment = 0;
    }

    if (not $footer_comment and (!/^\[?[a-zA-Z0-9-]+:/ or m|^[a-zA-Z0-9-]+://|)) {
      $footer = undef;
    }
  }

  splice(@msg, -$blank_lines) if $blank_lines;

  $attachment = $#msg + 1 unless defined $attachment;
  $footer = $attachment unless defined $footer;

  return (
    [ @msg[0..$footer-1] ],
    [ @msg[$footer..$attachment-1] ],
    [ @msg[$attachment..$#msg] ]
  );
}

sub add_change_id
{
  return @_ if grep(/^Change-Id:/, @_);
  my ($m, $f, $a) = split_message(@_);

  return (@$m, '', "Change-Id: I".get_160bit_rnd(), '', @$f, @$a);
}


$commands->add('commit' => {
  syn => [
    '%c %o [<project>...]',
    [ 'message|msg|m=s',    'The commit message', { arg => '<msg>' } ],
    [ 'file|F=s',           'File containing the commit message', { arg => '<msg-file>' } ]
  ],
  desc => qq|Create a single commit across multiple projects. The commit
             will get the same commit message and mor importent the same
             change ID.|,
  cmd => sub {
    my ($opts, $command, $cmd) = @_;

    my @index;
    my @changes;
    my @untracked;
    my @conflicts;
    my @commit_prj;

    foreach_prj {
      my $prj = $_;
      my $s = $prj->status;
      return 0 if not $s->is_dirty;
      my @i = $s->pretty_index($prj->{path});
      push @index, @i;
      push @commit_prj, $prj if @i;
      push @changes, $s->pretty_changed($prj->{path});
      push @untracked, $s->pretty_untracked($prj->{path});
      push @conflicts, $s->pretty_conflicts($prj->{path});
      return 0;
    } \@ARGV;

    if (not @commit_prj) {
      if (@changes) {
        print "\nChanges not staged for commit:\n";
        print "\t".colored($_, 'red')."\n" foreach @changes;
      }

      if (@untracked) {
        print "\nUntracked files:\n";
        print "\t".colored($_, 'red')."\n" foreach @untracked;
      }
      print "\nno changes to commit\n";
      return 0;
    }

    if (@conflicts) {
      print "\nFiles with merge conflicts:\n";
      print "\t".colored($_, 'red')."\n" foreach @conflicts;
      return 100;
    }

    my @msg;
    my $edit = 1;
    if (defined $opts->{message}) {
      my $m = $opts->{message};
      $m =~ s,\\n,\n,g;
      $m =~ s,\\t,\t,g;
      @msg = split /^/, $m;
      chomp @msg;
      $edit = 0;
    } elsif (defined $opts->{file}) {
      open my $f, "<$opts->{file}" or die "fatal: cannot open message file $opts->{file}: $!";
      @msg = <$f>;
      close $f;
      chomp @msg;
      $edit = 0;
    } else {
      push @msg, '';
      push @msg, q|# Please enter the commit message for your changes. Lines starting'|,
                 q|# with '#' will be ignored, and an empty message aborts the commit.|;

      push @msg, '#', '# Projects with commits:';
      push @msg, map { "#\t$_->{name}:   $_->{path}" } @commit_prj;


      if (@index) {
        push @msg, '#', "# Changes to be commited:";
        push @msg, map { "#\t$_" } @index;
      }

      if (@changes) {
        push @msg, '#', "# Changes not staged for commit:";
        push @msg, map { "#\t$_" } @changes;
      }

      if (@untracked) {
        push @msg, '#', "# Untracked files:";
        push @msg, (map { "#\t$_" } @untracked);
      }
      push @msg, '#';
    }

    my $file = File::Spec->catdir(get_repo_dir(), 'COMMIT_EDITMSG');
    my @m = add_change_id(@msg);
    open my $commit_msg, "+>$file" or die "fatal: cannot open message file $file: $!";
    print $commit_msg "$_\n" foreach @m;
    close $commit_msg;

    if ($edit) {
      my $ed = $ENV{EDITOR};
      if (not $ed or $ed eq '') {
        print STDERR "fatal: no editor for commit message: please set EDITOR= in your environemt";
        return 128;
      }
      system("$ed $file");
    }

    my $empty = 1;
    open $commit_msg, "<$file" or die "fatal: cannot open message file $file: $!";
    while (<$commit_msg>) {
      next if /^#/;
      next if /^\s*$/;
      next if /^Change-Id:/;
      $empty = 0;
      last;
    }
    close $commit_msg;

    if ($empty) {
      print STDERR "Aborting commit due to empty commit message.\n";
      return 100;
    }

    foreach my $p (@commit_prj) {
      print "commting in: $p->{path}\n";
      print $p->git->run(commit => '-F', $file), "\n";
    }
  }
});

###### add ####################################
$commands->add('add' => {
  syn => [
    '%c %o [<project>...]',
  ],
  desc => qq|Add files to the git index of individual projects.|,
  cmd => sub {
    my ($opts, $command, $cmd) = @_;
    my @files = @ARGV;
    my $all_projects = load_projects();
    my %projects;
    foreach my $file (@files) {
      my ($p, $path) = project_for_path($all_projects, $file);
      if (not $p) {
        push @$err, "no matching project found for file: $file";
        next;
      }

      if (not -e $file) {
        push @$err, "file $file does not exist";
        next;
      }

      $projects{$p->{name}} = [] unless $projects{$p->{name}};
      push @{$projects{$p->{name}}}, $path;
    }

    print_errors(exit => 128);
    while (my ($n, $files) = each %projects) {
      my $p = $all_projects->{$n};
      die "fatal: internal error: project $n not in our list" unless defined $p;
      $p->git->run('add', '--', @$files);
    }

    return 0;
  }
});


if (-r $user_config) {
  my @cfg = qx{git config --file $user_config --list};
  my %config = ();
  foreach (@cfg) {
    if (/^([^=]+)\.([^.]+)=(.*)$/) {
      $config{$1}{$2} = $3;
    }
  }

  while (my ($alias, $t) = each %{$config{alias}}) {
    $commands->alias($alias, $t);
  }
}

## the main program #####################################
exit($commands->run($prog));


### git commit-msg hook for adding Change IDs #############################
sub gerrit_commit_msg_hook()
{
return <<'EOF';
#!/bin/sh
# From Gerrit Code Review 2.8.1
#
# Part of Gerrit Code Review (http://code.google.com/p/gerrit/)
#
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

unset GREP_OPTIONS

CHANGE_ID_AFTER="Bug|Issue"
MSG="$1"

# Check for, and add if missing, a unique Change-Id
#
add_ChangeId() {
	clean_message=`sed -e '
		/^diff --git a\/.*/{
			s///
			q
		}
		/^Signed-off-by:/d
		/^#/d
	' "$MSG" | git stripspace`
	if test -z "$clean_message"
	then
		return
	fi

	if test "false" = "`git config --bool --get gerrit.createChangeId`"
	then
		return
	fi

	# Does Change-Id: already exist? if so, exit (no change).
	if grep -i '^Change-Id:' "$MSG" >/dev/null
	then
		return
	fi

	id=`_gen_ChangeId`
	T="$MSG.tmp.$$"
	AWK=awk
	if [ -x /usr/xpg4/bin/awk ]; then
		# Solaris AWK is just too broken
		AWK=/usr/xpg4/bin/awk
	fi

	# How this works:
	# - parse the commit message as (textLine+ blankLine*)*
	# - assume textLine+ to be a footer until proven otherwise
	# - exception: the first block is not footer (as it is the title)
	# - read textLine+ into a variable
	# - then count blankLines
	# - once the next textLine appears, print textLine+ blankLine* as these
	#   aren't footer
	# - in END, the last textLine+ block is available for footer parsing
	$AWK '
	BEGIN {
		# while we start with the assumption that textLine+
		# is a footer, the first block is not.
		isFooter = 0
		footerComment = 0
		blankLines = 0
	}

	# Skip lines starting with "#" without any spaces before it.
	/^#/ { next }

	# Skip the line starting with the diff command and everything after it,
	# up to the end of the file, assuming it is only patch data.
	# If more than one line before the diff was empty, strip all but one.
	/^diff --git a/ {
		blankLines = 0
		while (getline) { }
		next
	}

	# Count blank lines outside footer comments
	/^$/ && (footerComment == 0) {
		blankLines++
		next
	}

	# Catch footer comment
	/^\[[a-zA-Z0-9-]+:/ && (isFooter == 1) {
		footerComment = 1
	}

	/]$/ && (footerComment == 1) {
		footerComment = 2
	}

	# We have a non-blank line after blank lines. Handle this.
	(blankLines > 0) {
		print lines
		for (i = 0; i < blankLines; i++) {
			print ""
		}

		lines = ""
		blankLines = 0
		isFooter = 1
		footerComment = 0
	}

	# Detect that the current block is not the footer
	(footerComment == 0) && (!/^\[?[a-zA-Z0-9-]+:/ || /^[a-zA-Z0-9-]+:\/\//) {
		isFooter = 0
	}

	{
		# We need this information about the current last comment line
		if (footerComment == 2) {
			footerComment = 0
		}
		if (lines != "") {
			lines = lines "\n";
		}
		lines = lines $0
	}

	# Footer handling:
	# If the last block is considered a footer, splice in the Change-Id at the
	# right place.
	# Look for the right place to inject Change-Id by considering
	# CHANGE_ID_AFTER. Keys listed in it (case insensitive) come first,
	# then Change-Id, then everything else (eg. Signed-off-by:).
	#
	# Otherwise just print the last block, a new line and the Change-Id as a
	# block of its own.
	END {
		unprinted = 1
		if (isFooter == 0) {
			print lines "\n"
			lines = ""
		}
		changeIdAfter = "^(" tolower("'"$CHANGE_ID_AFTER"'") "):"
		numlines = split(lines, footer, "\n")
		for (line = 1; line <= numlines; line++) {
			if (unprinted && match(tolower(footer[line]), changeIdAfter) != 1) {
				unprinted = 0
				print "Change-Id: I'"$id"'"
			}
			print footer[line]
		}
		if (unprinted) {
			print "Change-Id: I'"$id"'"
		}
	}' "$MSG" > "$T" && mv "$T" "$MSG" || rm -f "$T"
}
_gen_ChangeIdInput() {
	echo "tree `git write-tree`"
	if parent=`git rev-parse "HEAD^0" 2>/dev/null`
	then
		echo "parent $parent"
	fi
	echo "author `git var GIT_AUTHOR_IDENT`"
	echo "committer `git var GIT_COMMITTER_IDENT`"
	echo
	printf '%s' "$clean_message"
}
_gen_ChangeId() {
	_gen_ChangeIdInput |
	git hash-object -t commit --stdin
}


add_ChangeId

EOF
}
